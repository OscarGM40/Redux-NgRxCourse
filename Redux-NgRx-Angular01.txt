					REDUX Y NGRX EN ANGULAR

Playlist: https://www.youtube.com/watch?v=sgFQjRL5niY&list=PLCKuOXG0bPi3FtoplJe0JOpiV6OyK30wd&index=2
* Todo lo de la playlist está en el curso de Udemy.

						SECCION 02 

NOTA: puedo ver las versiones de typescript o rxjs de Angular con ng version

En esta sección es introductoria y con mucha teoría, no se preocupen intente hacer cada video entretenido y lo suficiente explícito para que comprendan los fundamentos de Redux antes de empezar con el código.

Aquí veremos cosas como:

1- ¿Qué es Redux?
2- ¿Para qué sirve?
3- Que son las:
    a- Acciones
    b- Reducers
    c- State
    d- Store
Al final, también les dejo un enlace con la documentación oficial de Redux por si acaso quieren saber más teoría

						VIDEO 08 QUE ES REDUX

Redux no es más que un patrón para el manejo de la información.Me permitirá acceder a información que conteste a preguntas como:
¿Cual es el estado de la aplicación?
¿Cual es el valor de determinado variable?
¿Quien cambió ese valor?
¿En que momento cambió? ...etc

NOTA: puedo implementar redux en Angular,React,Vue,VanillaJs,... es un patrón agnóstico.

IDEAS PRINCIPALES:

1- Toda la data de la aplicación se encuentra en una estructura previamente definida(initialState)
2- Toda la información se encontrará almacenada en un único lugar,el STORE.Este strore normalmente contiene el 99% de la información.
3- El store JAMÁS SE MODIFICA de forma directa.Nunca muta.
4- Las interacciones del usuario y/o código dispara acciones que describen qué sucedió.Todo esto lo puedo ver en las DevTools
5- El valor actual de la información de la aplicación se llama estado-STATE
6- Un nuevo estado es creado en base a la combinación del viejo estado y una ACCIÖN,mediante una función llamada REDUCER

NOTA:recuerda que se cambia de estado tomando una acción(la cual me guiará al reducer) y el VIEJO ESTADO.El reducer tomará esa acción y el viejo estado y produce un nuevo estado.

VENTAJAS. En una aplicación pequeña, con pocas entradas y manejo de datos, implementar el redux es mucho tiempo para algo simple y poco confuso.

Pero en una aplicación con muchos componentes, con muchos servicios y modificaciones a la información, es muy difícil saber quien modificó que... o como se debería de comportar la aplicación... la idea del patrón es que sea predecible y fácil de entender por todos los desarrolladores, que quede claro qué acción es ejecutada y en qué momento se actualiza la misma.

			VIDEO 09 CONCEPTOS ACTION-REDUCER-STATE-STORE

Estas cuatro estructuras son fundamentales para entender el patrón redux.Son las acciones,el reducer,el state y el store

Action: es la única fuente de información que se envía por interacciones de usuario o programa.Por lo general,se busca que las acciones sean lo más simples posibles
Una actión únicamente tiene dos propiedades,el type y el payload,que es opcional.
El payload es la menor cantidad posible de información necesaria para realizar dicha tarea.El type si es obligatorio

Reducer: no es más que una simple función que recibe dos argumentos y siempre retorna un nuevo estado.Recibe el oldState y las acciones.
El oldState es el estado actual de la aplicación.
La action es un plain object que indica qué hay que hacer.Recuerda que las acciones y el payload deben ser lo más simples posibles.

El state:es un objeto que representa el estado de la aplicación.Tiene ciertas reglas:
1- El state es de sólo lectura
2- Nunca se mutará el state de forma directa
3- Hay funciones prohibidas de Javascript como el push(básicamente cualquier cosa que modifique objetos ya que todos los objetos son pasados por referencia).
 
El store es un objeto con las siguientes responsabilidades:
1- Contiene el estado de la aplicación
2- Permite la lectura del mismo(via getState())
3- Permite crear un nuevo estado al utilizar dispatch(ACTION)
4- Permite notificar los cambios(via subscribe())

Estos cuatro conceptos son fundamentales.Una action es un plain object con dos proiedades,un reducer toma el oldState y una action y devuelve uno nuevo.El state es un object que representa el estado de la app y el store básicamente gestiona todo por nosotros.

NOTA:puedo consultar su web oficial aquí:
 https://es.redux.js.org/ <- redux normal
Aqui en Inglés: https://redux.js.org/ <- redux toolkit

Usar la de inglés que suele ser mejor.

			SECCION 03 IMPLEMENTAR REDUX DESDE CERO EN JS 

Aquí tocaremos temas como:

1- Crear el patrón Redux desde absoluto cero
2- Integrar TypeScript para correrlo con Node
3- Crear acciones
4- Crear reducers básicos
5- Organización del proyecto y sus ejemplos
6- Manejo del Store
7- Subscripciones de cambios en el Store.

Al final de esta sección, tienen el código fuente que pueden descargar para compararlo contra el suyo en caso de ser necesario

						VIDEO 14 REDUX BÁSICO

Antes de empezar con librerias y ngRx vamos a crear un ejemplo básico,eso si,en typescript.Para usar typescript lo mejor es usar ts-node(puedo buscar en npm por el módulo).
Me pedirá instalar(siempre en global) typescript y el compilador/ejecutor ts-node:npm i -g ts-node
npm i -g typescript
Puedo ver con npm ls -g que ya los tengo.Bien podría instalarlos a nivel de proyecto en vez de en mi Sistema Operativo pero se supone que los voy a usar a menudo.
Sin embargo podría instalarlos a nivel de proyecto si fuera necesario.
npm i ts-node -D 
npm i typescript -D <- al ser typescript debería instalarlos en modo dev!

Para ejecutarlo sin la libreria de forma global puedo usar varias aproximaciones:1- npx viene incluido con la instalación de node y permite ejecutar paquetes instalados en el proyecto local:
npx ts-node app.ts
2- crear un script referenciando la libreria
scripts: {
 "run":"./node_modules/.bin/ts-node" <- pues eso

				VIDEO 15 ACCIONES Y REDUCER NIVEL BÁSICO

Para definir una acción puedo hacerlo de varias formas,pero una muy simple y sencilla es definir una interfaz con las propiedades type y payload,éste último opcional, ya que una Action debe ser un objeto que cumple esto:

interface Action {
  type: string;
  payload?:any
}

Despues ya puedo declarar acciones que cumplan este contrato:
const incrementadorAction:Action = {
   type:'INCREMENTAR'
}
Y la función reducer es una simple función que recibe un oldState(no undefined) y una  acción(ojo,recibe una).Al ser un oldState la primera vez será el initialState.Nunca puede ser undefined el state:

function reducer(state=10,action:Action){
  switch(action.type){
  	case 'INCREMENTAR':
      return state += 1;
    default:
      return state;
  }
Lógicamente no se le pasa el state=10 sino una interface/clase.

			VIDEO 16 CREANDO MÁS ACCIONES EN NUESTRO REDUCER

Puede parecer que un reducer no es más que un gigantesco switch dentro de una función,y es cierto.Sin embargo suele separarse en pequeños reducer separando la lógica de mi aplicación.
Dado que es una función pura no puedo usar peticiones http en ese switch,por ejemplo 
Importante,el operador +number no quita los decimales ni pasa a string:
+67.77777 + 1 = 68.77777 as Number
simplemente pasa a Number

Volviendo al video,destacar que cuando una acción necesita pasar un argumento se usa el payload.Como no siempre lo hará por eso es opcional:

function reducer(state = 10, action: Action) {
  switch (action.type) {
    case 'INCREMENTAR':
      return state + 1;
    case 'DECREMENTAR':
      return state - 1;
    case 'MULTIPLICAR':
      return state * +action.payload;
    case 'DIVIDIR':
      return +(state / +action.payload).toFixed(4);
    default:
      return state;
  }

				VIDEO 17 ORGANIZANDO MEJOR EL PROYECTO

No es buena idea tener todo en un archivo como tenemos ahora mismo.Asi pues creo un folder para las interfaces.Un dato interesante,la librería de redux es muy pequeña,como de unas cien líneas.
En cuanto al archivo de las acciones irá en su folder,en este caso 'contador' y es un standar ponerle .actions.
Lo mismo para el reducer es un standar usar xxxReducer en su nombre.Irá junto a las acciones para el mismo.

					VIDEO 18 STORE

Debemos crear un store que almacene el estado actual de la aplicación tras cada cambio.Al usar clases por estar en Angular cambia un poco,ya que hay que definir una clase con un getter de acceso a su propiedad privada state:

class Store<T> {
  constructo( private reducer:Reducer<T>,private state:T){}
  getState():T{ return this.state; }
}
La interfaz para esa propiedad reducer
export interface Reducer<T>{
  (state:T,action:Action):T
  }
Ahora,para crear un estado inicialializo una instancia(confirmar que es así por ser Angular).
const store = new Store(reducer,10);
* Y para acceder al state necesitaré usar el getter ya que está encapsulado.Genial:
console.log(store.getState());

Recuerda que el store tiene dos objetivos fundamentales,albergar los cambios en el state y disparar las acciones.Sin él no podría persistir los cambios en el state.
Asi pues nos falta definir el método dispatch en la clase Store:
  /* recuerda que el dispatch es una función que recibe una action por argumento.Despues retornará un newState */
  dispatch(action: Action):void{
    this.state = this.reducer(this.state,action);
  }

Lógicamente,ya no debo disparar las acciones con el reducer,sino con este método:/* Usando el dispatch del store.BIEN.Cada cambio en el state queda persistido localmente. */
store.dispatch(incrementadorAction);
store.dispatch(incrementadorAction);
console.log(store.getState());
store.dispatch(decrementadorAction);
console.log(store.getState());
store.dispatch(multiplicarAction);
console.log(store.getState());
store.dispatch(dividirAction);
console.log(store.getState());
store.dispatch(resetAction);
console.log(store.getState());

Puedo ver que ha sido facilisimo implementar este patrón en vanilla JS/TS con una simple clase,apenas dos interfaces y una función.
Por último,es un dolor de cabeza tener que usar console.log para ver el newState.Redux ya trae funcionalidad para que yo pueda ser notificado cuando cambie el estado.Nosotros somos notificados a través de un Observable al que podemos suscribirnos.Genial.

				VIDEO 19 SUSCRIBIRME A LOS CAMBIOS DEL STATE 

Dado que vamos a usar la librería de redux no vamos a tener que definir esa clase tan compleja,podríamos definir todo para poder acceder a ese Observable,pero dado que ya lo han hecho ellos desde ya vamos a usar su librería y ver como se reduce el código:
npm i redux <- recuerda que esto es para puro Javascript,faltará el adapter

Ya me proveen ellos una función que creará esa Clase,sus métodos dispatch,getState,la propiedad encapsulada state con el estado actual,etc.. Perfecto:
import { Store,createStore } from 'redux';
cons store = createStore(contadorReducer);
store.dispatch(incrementadorAction) <- tengo acceso a todo gracias a ellos
console.log(store.getState()); <- dará 11.

* Bien,pero habiamos dicho que incluso nos dan un Observable para poder suscribirnos en cada cambio del state(Store._state).

/* 4- Pero lo más genial de todo es que ya nos dan incluso un Observable para suscribirnos.Es la propia ejecución de la función createStore la que es un Observable */

/* no recibe nada en el observer,ya lo manejan ellos.Fijate que esto es genial,pues puedo ser notificado */
store.subscribe( () =>{
  console.log('Nuevo state',store.getState());
});
Fijate que esto cambia mucho de lo que tenia pensado.Podría ejecutar cualquier lógica al cambiar determinada propiedad del newState.Seguir investigando.

Redux puede ser descrito en tres principios fundamentales:Unica fuente de la verdad,el state es de solo lectura y los cambios en él se realizan con funciones puras.

NOTA:el flujo de datos en una aplicación con redux es unidireccional y siempre sigue la misma dirección y el mismo sentido:


IMPORTANTE: El ciclo de duración de la data en cualquier aplicación Redux sigue estos 4 pasos:
1- Haces una llamada a store.dispatch(action).
  Puedes invocar store.dispatch(action) desde cualquier lugar en tu aplicación, incluyendo componentes y XHR callbacks, o incluso en intervalos programados.

2- El store en Redux invoca a la función reductora que le indicaste(dado que uśe store.dispatch y la instancia store tiene acceso al método reducer).
El store pasará dos argumentos al reductor,el oldState(o estado actual) y la action.Tenga en cuenta que un reductor es una función pura.No debe realizar ningún efecto alterno como las llamadas al API o las transiciones del router. Esto debe suceder antes de que se envíe la acción.

3- El reductor raíz puede combinar la salida de múltiples reductores en un único árbol de estado.
Como se estructure el reductor raíz queda completamente a tu discreción. Redux provee una función combineReducers() si quiero combinar reductores(no es importante pues este paso)

4-El store en Redux guarda por completo el árbol de estado devuelto por el reductor raíz.
¡Este nuevo árbol es ahora el siguiente estado de tu aplicación!
Cada listener registrado usando store.subscribe(listener) será ahora invocado; los listeners podrán invocar store.getState() para obtener el estado acutal.
Ahora, la interfaz de usuario puede actualizarse para reflejar el nuevo estado(de echo un cambio actualiza la interfaz).

En cuanto a acciones asincronas ya no puedo usar el reducer.Como primera opción se usa el middleware tunk que se pone en medio del dispatch de una accion(luego es un middleware) hace lo que tenga que hacer y devuelve a la accion lo necesario:
Sin middlewares, Redux sólo soporta flujos de datos síncronos. Es lo que obtienes por defecto con createStore().
Para usar asincronia debo mejorar createStore() con applyMiddleware().

export function fetchPosts() {
  return (dispatch, getState) => {
      ... codigo aśincrono...

NOTA: Thunk middleware no es la única manera de orquestar acciones asíncronas en Redux:
1- Puedes utilizar redux-promise o redux-promise-middleware para enviar Promesas en lugar de funciones.
2- Puedes utilizar redux-observable para enviar Observables.
3- Puedes utilizar el middleware redux-saga para construir acciones asíncronas más complejas.
4- Puedes utilizar el middleware redux-pack para enviar acciones asíncronas basadas en Promesas.

Puedo observar la gran idea que es instalar redux y usar su método createStore en vez de crear yo la clase.Pero aún falta ver como usar todo esto en una aplicación de Angular.

			SECCION 04 REDUX EN UNA APLICACION DE ANGULAR

NOTA:para usar las redux dev tools en Firefox : https://addons.mozilla.org/en-US/firefox/addon/reduxdevtools/

Primero vamos a crear una jerarquia de componentes Padre Hijo Nieto y ver como se pasan props entre ellos sin redux,para ver los problemas.Despues lo haremos con redux,para poder comparar.Perfecto.

Esta sección tiene por objeto hacer una demostración del poder real de manejo centralizado de la información de nuestra aplicación... pero quiero que ustedes mismos lo descubran por su cuenta.

Aquí crearemos una aplicación básica de Angular y tocaremos temas como:

1- Creación de una aplicación de Angular de 1 componente y 2 hijos
2- Reforzamiento de temas como EventEmitter, junto a los Inputs y Outputs de Angular
3- Implementar el patrón Redux utilizando NgRx
4- Action creator
5- DevTools
6- Centralizar la lógica en acciones y reducers
7- Disparar acciones
8- Escuchar cambios en el Store
9- Y mucho más
Esta sección nos será de mucha ayuda, ya que nos permite comprender uno de los principales beneficios de trabajar con el patrón Redux

Con todo esto creo una app de angular y le instalo bootstrap(npm i bootstrap).Al instalarlo asi hay que especificarlo en el angular.json siempre.
       "styles": [
              "src/styles.css",
              "node_modules/bootstrap/dist/css/bootstrap.min.css"
            ],
Si lo pusiera el AngularCLI me dará un error asi que no tiene pérdida.

				VIDEO 25 CREACIÓN COMPONENTES ADICIONALES

Vamos a crear un par de contadores y recibir las props de forma normal entre ellos,con @Input y @Output:

El hijo simplemente recibe el contador y envia el valor nuevo al padre,ya que él puede multiplicar y dividir esa variable:number llamada contador:

export class HijoComponent implements OnInit {

  @Input() contador!:number;
  @Output() contadorChange = new EventEmitter<number>();

  constructor() { }

  multiplicar(){
    this.contador *= 2;
    this.contadorChange.emit(this.contador);
  }
  
  dividir(){
    this.contador /= 2;
    this.contadorChange.emit(this.contador);
  }

Su template no es nada del otro mundo:
<h3>Contador</h3>
<h4>{{ contador }}</h4>

<div class="row text-center">
  <div class="col">
    <button 
      (click)="multiplicar()"
       class="btn btn-primary">Multiplicar
    </button>
    <button
     (click)="dividir()"
     class="btn btn-info">Dividir
    </button>
  </div>
</div>

El padre puede incrementar y decrementar.Aparte renderiza al hijo:
<div class="row text-center mt-3">
  <div class="col">
    <button
      class="btn btn-primary me-2"
      (click)="incrementar()">
        Incrementar
      </button>
    <button 
      class="btn btn-info"
      (click)="decrementar()">
        Decrementar
      </button>
  </div>
</div>

<hr>

<div class="row text-center">
  <div class="col">
    <app-hijo 
    [contador]="contador"
    (contadorChange)="contador = ($event)">
    ></app-hijo>
  </div>
</div>

export class AppComponent {
  contador:number;

  constructor(){
    this.contador = 10;
  }

  incrementar(){
    this.contador++;
  }

  decrementar(){
    this.contador--;
  }
Realmente hasta ahora no hay problemas,aunque ya se puede apreciar los futuros problemas que tendría como dev siguiendo con este aprroach,y serán graves.

				VIDEO 26 INTEGRAR COMPONENTE NIETO

Hagamos lo mismo,renderizemos en el componente hijo al nieto:

En el nieto hacemos lo mismo,puedo recibir el contador,pero ¿que pasa si este componente también quiere hacer algo sobre el contador?.Por ejemplo un reset:

<button class="btn btn-danger"
  (click)="reset()">Reset
</button>

* Hay que mandarlo a todos ahora,claro
export class NietoComponent implements OnInit {
  @Input() contador!:number;
  @Output() resetContador = new EventEmitter();
  constructor() { }

  ngOnInit(): void {
  }

  reset(): void {
    this.contador = 0;
    this.resetContador.emit(this.contador);
  }

Claro que el hijo ahora ya no puede hacer esto:
  <div class="col">
    <app-nieto 
      [contador]="contador"
      (resetContador)="contador = $event">
    </app-nieto>

TEndrá que crearse una función en su clase que mande al padre y además actualize su propia variable contador(que es la misma ya que estamos por referencia cual prehistorics).

* Ya no puedo usar una simple igualación:
<app-nieto [contador]="contador" [resetContador)="contadorReset($event)">
* Y en la clase

  contadorReset(value: number){
    this.contador = value;
    this.contadorChange.emit(this.contador);
  }

Bien,realmente ya está pero puede apreciarse la ingente cantidad de directivas @Input y @Output creadas.Con el patrón redux no habrá que hacer esto,ya que toda la información se va a encontrar centralizada en un mismo lugar.
Veamos pues como hacer esto con redux

				VIDEO 27 IMPLEMENTAR NGRX EN UN PROYECTO

La web oficial para redux-angular(ngrx) es esta: https://ngrx.io/
Puedo ver un diagrama con el flujo de la información.En esta versión se añaden un par de cosas,ya que es un Selector(una suscripción) la que notifica a la vista cualquier cambio en el Store y a su vez un Service usará Effects(efectos) para comunicarse con el dispatch(es decir,para disparar alguna acción necesitará un efecto).Y de forma reversa,un dispatch también necesita un efecto para comunicarse con un servicio.Ya veremos todo esto.De momento instalamos la libreria:

npm install @ngrx/store

Ahora ya es ir creando las acciones,el reducer,el store y el provider.Empecemos por las acciones.Simplemente sigo la convención,creando un xxx.actions.ts:

En contador.actions.ts
/* con la función createAction obviamente puedo crear acciones */
import { createAction } from "@ngrx/store";

export const incrementar = createAction("[Contador] Incrementar");
export const decrementar = createAction("[Contador] Decrementar");

Ahora es turno del xxx.reducer.ts.De momento lo implementaremos con la típica función,aunque ya proveen ellos un método que crea un reducer:

import { Action } from "@ngrx/store";
import { decrementar, incrementar } from "./contador.actions";

export function contadorReducer(
  state:number=10,
  action:Action
  ){
  switch(action.type){
    case incrementar.type:
      return state+1;
    case decrementar.type:
      return state-1;
    default:
      return state;
  }
NOTA:Fijate que me proporcionan ellos la interfaz Action que tuvimos que crear.Realmente es la misma interfaz que creamos en la sección anterior.

Despues de las acciones y el reducer es tiempo del store.Hay que importar el StoreModule en el app.module.ts.De forma similar al Routes.forRoot() hay que pasarle el rootReducer.De momento es obvio cual es:

  imports: [
    BrowserModule,
    StoreModule.forRoot({ contador: contadorReducer }) <- contador es el nombre que le quiero dar yo,contadorReducer es el reducer

Esto de por si aún no me permite usar este Store(aunque si que lo he configurado).Al instalar ngrx/store se me habilita poder inyectar la clase Store.Hagamoslo en un punto alto(en el app.component.ts,más alto no hay):
constructor( private store:Store<{contador:number}>){
Recuerda que el store es un Observable asi que me suscribo.Puedo hacerlo en el constructor o en el ngOnInit:
  this.store.subscribe( state => {
      console.log(state);
    } );

Y lógicamente los métodos incrementar,decrementar,multiplicar,... tendré que definirlos en el reducer,darles un type,etc y llamarlos mediante esta inyección.Genial:
  incrementar(){
    // this.contador++;
    this.store.dispatch( incrementar() );
  }

  decrementar(){
    // this.contador--;
    this.store.dispatch(decrementar());
  }

NOTA:es un estandar que se importen las acciones asi:
import * as actions from 'actions/todo.actions.ts';
y ahora las llamo asi this.store.dispatch(actions.decrementar()).Investigar más sobre esto.Fijate que asi queda mucho más claro que he llamado a una acción y no a un método cualquiera,luego parece buena idea seguir esta convención.
NOTA: no se puede mutar el estado ya que si lo muto no puedo saber cual es el oldState,pues lo he mutado

				VIDEO 29 STORE DEV TOOLS

Puedo instalar el plugin Redux DevTools tanto en Chrome como Firefox(buscarlo simplemente).Aparte del plugin en Angular debo instalar esta libreria:

npm install @ngrx/store-devtools
Con esta libreria tengo acceso al StoreDevtoolsModule(el cual debo configurar).De nuevo lo importo en un punto alto(al parecer es siempre el app.module):

    StoreDevtoolsModule.instrument({
      maxAge: 25, // Retains last 25 states
      logOnly: environment.production, // si estoy en produccion las devtools son de solo lectura,si estoy en desarrollo puedo cambiar cosas del state
    }),
  ],
Puedo observar que hay que configurar el numero máximo de estados a los que puedo acceder para debuggear(esto es solo para debugging,lógicamente no hay un numero máximo de cambios que puedo realizar en mi app).
También hay que especificar cuando deben ser de modo lectura y cuando de lectura/escritura estas devtools
Ahora si que ya puedo ver la pestaña redux en las ChromeDevTools.fijate que puedo sacar la barra del históricon con el icono del reloj de abajo e ir a cada state con 'jump'.Con jump además me quedaré en ese state hasta que lo cambie

También tengo iconos para descargar el state a un json y para importarlo desde un file.
También puedo fijar un initialState con la opcion 'commit' que esta al lado del jump.
Y cuando crece mucho la app puedo verlo de forma gráfica con la opción de chart.
Con la opción de diff activada veo los cambios que se realizaron

		VIDEO 30 ESCUCHAR CAMBIOS DE UN ELEMENTO EN CONCRETO DEL STATE

Realmente casi nunca voy a querer suscribirme a TODOS los cambios que se produzcan en el state:
this.store.subscribe(state => ...) <- aqui me suscribo a todos,cualquier cambio lo va a disparar,fijate que lo que recojo es todo el state

Claro que yo sólo quiero saber cuando cambia el contador.Para ello la instancia que inyectamos 'store' ya viene con el método select.Este método me va a permitir seleccionar el nodo que me interesa:

this.store.select('contador').subscribe(contador =>) <- simplemente es pasar antes por el select.Fijate que ya no se me devuelve todo el state,sino que sería el state.contador que llamaré contador
Además,usar select limita la cantidad de emisiones:
   /* fijate que SÓLO UN CAMBIO EN EL CONTADOR DISPARA ESTE OBSERVABLE.Perfecto  */
    this.store.select('contador').subscribe( contador => this.contador = contador );
NOTA: seguir viendo redux toolkit

					VIDEO 31 CREATEREDUCER

Recuerda que nos habiamos saltado un paso.NgRx también proporciona una forma de crear la función pura reductora,no hace falta que lo haga yo(aunque puedo usar mi función si quiero)
Su función createReducer es más eficiente porque no trabaja en base a un switch.Trabaja en base a funciones suyas de la misma libreria ngrx con el objetivo de mejorar la velocidad de respuesta de mi app.
Además,también es más sencillo de implementar.Veamoslo en código:

/* FORMA CON NGRX Y CREATEREDUCER */
export const initialState = 10;
/* la función 'on' permite seleccionar más rápidamente la acción que en el switch  */
const _contadorReducer = createReducer(
  initialState,
  on(incrementar, state => state + 1),
  on(decrementar, state => state - 1)
  )

/* ojo que usar la forma anterior implica tener que realizar este paso,pues es el retorno de la función anterior lo que se exporta al store */

export function contadorReducer(state:number=initialState, action: Action) {
  return _contadorReducer(state, action);
}
/* esto asegura la no-mutación */
NOTA: TS se volvió mas estricto,hay que pasarle el tipo y valor por defecto al parámetro state.
En el siguiente video veré como pasar argumentos a las acciones.

					VIDEO 32 STORE EN EL COMPONENTE HIJO

Es momento de recuperar nuestro componente hijo.
NOTA:NaN*2 es NaN,cualquier operación sobre NaN será NaN.

Fijate que en cuanto llego a la clase del Hijo ya empiezo a ver los beneficios y la legibilidad en el código.NO necesitaré un eventEmitter ni recibir props:
/*   @Input() contador!:number;
  @Output() contadorChange = new EventEmitter<number>(); */ <- prehistoric code

NOTA:fijate que en Angular siempre estoy bajo Typescript.Esto va a cambiar varias cosas,por ejemplo Store<T> siempre será de un tipo concreto.Contodo esto inyecto la clase/Observable en el hijo:

constructor( 
    private store: Store<AppState>,
    ) {
  this.store.select('contador').subscribe(contador => this.contador = contador);
     }

Puedo observar lo fácil que es para un componente suscribirse a una parte del estado(o a varias).En el siguiente video si que veremos como usar payloads en ese createReducer de NgRx.

			VIDEO 33 CREANDO ACCIONES PARA MULTIPLICAR Y DIVIDIR

En cuanto quiera definir una accion que lleva un payload tengo que usar un segundo argumento en el createAction llamado props<T>.

export const multiplicar = createAction( "[Contador] Multiplicar",
  props<{ numero: number }>());
export const dividir = createAction( "[Contador] Dividir",
  props<{ numero: number }>());

En el reducer este argumento props viene como segundo argumento de la callback del metodo on(action.type,callback) del createReducer.Esto es fácil,asinto:
on(incrementar, (state) => state +1),
on(multiplicar, (state, {numero}) => state*numero <- ojo ,este argumento numero viene del props<T>, como era props<{numero:number}> pues la propiedad se llama numero.

NOTA: también puedo no desestructurar las props:
on(multiplicar, (state,props) => state*props.numero) 
Depende de lo que quiera yo como desarrollador.

Para llamar al dispatch de una acción cambia un poco debido a TS también:
this.store.dispatch( actions.multiplicar( {numero:2}) <- ahora es un objeto como argumento.Quizas pude usar props<number>??.Sea como sea son sólo un par de cambios.

			VIDEO 34 ACCION DE RESET DEL NIETO

Es un ejercicio,simplemente implementar el reset.Yo lo haré con props para reforzar.
NOTA:recuerda que he tenido que instalar dos librerias:
 "@ngrx/store": "^13.0.2",
 "@ngrx/store-devtools": "^13.0.2",  

					SECCION 05 TODOS-APP 

Vamos a crear la típica app de tareas,con un estado mucho más complejo que el contador anterior.También la desplegaremos en GitHubPages.Servirá para reforzar lo aprendido.
Tocaremos temas como:

1- Creación de componentes
2- Modelos
3- Acciones
4- Reducers
5- Estados
6- Estado inicial
7- Agregar tareas mediante acciones
8- Payload
9- Editar tareas
10- Despliegues a GitHub y GitHub Pages

Pero uno de los temas principales, es aclarar cómo romper la relación que tiene JavaScript con los objetos y que no sean procesados por referencia, si no que sean creados objetos nuevos. Y de esa manera siempre regresar nuevos estados.

				VIDEO 39 INICIO PROYECTO TODOS-APP

Creo un nuevo proyecto con ng new <name> y lo renombro a 03-todoapp.Me traigo el contenido del index.html del repo(solo lo de dentro del <body>).

Esto es el maquetado,para instalar los estilos hay que usar un modulo npm:
npm install todomvc-app-css.
Lógicamente falta referenciar estos estilos.Como siempre se hace en el angular.json(están en node_modules/todomvc-app-css/index.css)
Este paso lo que hace es indicar a Angular que esos estilos van a formar parte del bundle final de la app.
  "styles": [
     "src/styles.css",
     "./node_modules/todomvc-app-css/index.css" <- puede ser sin ./ también(sólo node_modules/todomvc...)
      ],
Ahora ya si puedo servirla con ng serve y deberían cargarse esos estilos.

				VIDEO 40 CREANDO LOS COMPONENTES

Siguiendo el video creo los componentes para el footer,todo-page,todo-add,todo-list,todo-item etc.Fijate como en cuanto crea un folder 'todo' le creamos su módulo.
		VIDEO 41 SEGMENTAR LA TEMPLATE QUE TENEMOS EN MÚLTIPLES COMPONENTES

Hora de segmentar todo el código que tenemos en los componentes que acabamos de crear.
Recuerda que uno de los objetivos de los módulos es que todo esté encapsulado.Asi que para que en el app.component.html yo tenga visión sobre el selector <app-todo-page> tengo que exportar el componente TodoPage a través de su modulo todo.module.ts
NOTA:fijate que no necesito exportar todos,solo el todoPage(que contiene a todos).
NOTA:ya me proveen ellos las clases completed(text-decoration:line-through),editing(lo convierte a <input>) para que yo pueda usar sobre un <li>
Realmente es sencillo segmentar la template que me proporciona Fernando.

		VIDEO 42 INSTALAR NGRX,MODELO PARA TODOS, ACCIONES Y REDUCER

Siempre debo crear un modelo de mis datos,en este caso creamos el directorio models dentro de todos,por semántica, dentro de ese folder creo el todo.model.ts:
export class Todo {
  public id: number;
  public texto: string;
  public completado: boolean;

  constructor(texto: string) {
    this.texto = texto.charAt(0).toUpperCase() + texto.slice(1);
    this.completado = false;
    this.id = new Date().getTime();
  }
}
Cada vez que cree una instancia solo necesito el texto,pero me va a crear las tres propiedades,dos de ellas con los valores 'false'l y newDate().getTime().Perfecto.Hora de instalar ngRx:

PASO UNO
npm install @ngrx/store
Y en el app.module.ts
imports:[
StoreModule.forRoot({todo:todoReducer}),] <-fijate que me pide el reducer

PASO DOS
Creo las acciones.Recuerda que el payload es props<T>() en ngrx:

import { createAction, props } from "@ngrx/store";
export const crearTodo = createAction(
  '[TODO] Crea un todo',
  props<{ texto: string }>());

PASO TRES
Creo el reducer más eficiente de ellos:

import { Action, createReducer, on } from "@ngrx/store";
import { Todo } from "../models/todo.model";
import { crearTodo } from "./todo.actions";

const initialState:Todo[]= [];

const _todoReducer = createReducer(initialState,
  on(crearTodo,(state,{texto}) => [...state,new Todo(texto)]),);

export function todoReducer(state=initialState,action:Action){
  return _todoReducer(state,action);
}

NOTA: Es buena idea crearse un snipet para esto,o simplemente copiar y pegar de otro proyecto.Fijate que aún queda instalar las reduxdevtools.

				VIDEO 43 DEVTOOLS Y STATE DE LA APP

Las devtools no tiene nada instalarlas:
npm install @ngrx/store-devtools --legacy-peer-deps

  StoreDevtoolsModule.instrument({
      maxAge:25,
      logOnly:environment.production
    }),
environment.production ya va a devolver false o true para logOnly:boolean.Fácil

Bien,hay que definir el initialState de todo el Store.Normalmente se llama Appstate.Esto es para pasarselo al rootReducer:

Podría ser algo como esto:
export interface AppState {
  todos: Todo[];
  usuario:{},
  loading: boolean;
}

pero dejaremos solo la propiedad todos:Todo[]. Ya veré donde usamos esto.

						VIDEO 44 AGREGAR UN TODO

Bie,vamos a usar formularios reactivos.Fijate que al usarlos,es decir,al importarl el módulo ReactiveFormsModule en el todo.module.ts tengo acceso a ellos.
TEnemos un único <input>,ni siquiera tiene un <form> pero esto me da igual,no necesito que esté en un form.

Perfectamente puedo definir un control y darle validaciones.LA clave es la clase FormControl(defaultValue,[validations]):

txtInput:FormControl;
constructor(){ this.txtInput = new FormControl('todo 01',[Validators.required)

Ahora para asignar la configuración de este formControl a mi <input> tengo que usar la propiedad formControl(no confundir con formControlName,la cual requiere de un <form> con la propiedad [formGroup]

<input [formControl]="txtInput"> <- como además va a enlazar a una propiedad de la clase debe llevar corchetes.

IMPORTANTE:quiero rescatar sólo el valor cuando se pulse el Enter(pero con el foco en el input) asi que en vez de (keyup) va a ser (keyup.enter)="agregar()".De nuevo,es importante entender que no necesito crear una localRef porque estoy trabajando con formularios reactivos y ya puedo acceder al value desde la clase:

<input [formControl]="txtInput" (keyup.enter)="agregar()">
Habrá que controlar que no se dé al Enter con el campo vacio,esto deja el control en invalid con el required que pusimos.
Inyectamos el store(ojo,siempre lleva un genérico)
constructor( private store:Store<AppState>){}

agregar(){
  if(this.txtInput.invalid){return}
  this.store.dispatch(crearTodo({texto:txtInput.value})
  this.txtInput.setValue(''); 
Por último limpio el campo con setVAlue(value).Genial.
Resumen: Store<T> siempre trae un tipo al inyectarlo.Es un tipo general que declaramos en el app.state.ts con todo el state de la app(o con una parte sólo??).
dispatch(actionName({prop:value}) para disparar una acción.La prop coincide con createAction('aaaa',props<{prop:type}>())
Un new FormControl(defaultValue,[Validations]) me permite crear un control suelto.Lo enlazo con [FormControl]="name" en la template.
(keyup.enter) rescata solo el evento keyup y además la tecla Enter,las demás las ignora.Y this.txtInput.setValue('') resetea el control(también puedo usar reset()Gran lección.Por ultimo fijate que no inicializamos FormBuilder pero aún asi necesitabamos el módulo al usar la class FormControl

			VIDEO 45 DESPLEGAR NUESTRA LISTA DE TODOS

Creamos tres o cuatro todos más y nos suscribimos en el todo-list.Fijate que en el this.store.select('todos') yo puedo saber ese nombre todos ya que será una propiedad de la interfaz AppState que define el estado general.
Fijate que era export interface AppState { todos:todo[]}
Siempre será una propiedad del T de Store<T>.
NOTA: yo debería cancelar la suscripción al store,pero dado que es una SPA sin rutas no nos importa para algo tan pequeño.
  <app-todo-item 
    *ngFor="let todo of todos"
    [todo]="todo"
    >
  </app-todo-item>
Fijate que aunque usemos Redux en este map/for bucle tengo que mandar el todo para que lo tome el hijo.Esto no tiene nada que ver con redux.

			VIDEO 46 TRABAJANDO CON LOS TODO-ITEMS

 Rescatar cada todo es bien fácil con la directive @Input.
NOTA:Angular permite varias formas de usar clases CSS de forma condicional:
SINTAXIS ONE: [class.my_class]="step==='step1'"
<li [class.completed]="todo.completado"> 
SINTAXIS DOS:[ngClass]="{'class':step==='step1'}" <- ojo que es una llave
<li [ngClass]="{'completed':todo.completado}"
SINTAXIS THREE:multiples opciones:
[ngClass]="{'my_class':step==='step1','other_class':step==='step2'}"
Hay más pero con estas tres es suficiente.La primera forma es bien fácil.

Bien,sigamos,en la label con el texto creamos un método para el dobleClick:
 <label (dblclick)="editar()">{{todo.texto}}</label>

A su vez hay que crear una referencia local al input que se genera y rescatarla con ViewChild:
  editar(){
    this.editando = true;
    setTimeout(() => {
      this.inputFisico.nativeElement.focus();
    }, 1);
  }
Esto es para que hagamos focus al input al hacer dobleClick y entremos con el cursor(también podemos seleccionarlo entero con this.ref.nativeElement.select(),asi sólo hay que borrarlo con una pulsación.
Y además esa propiedad boleana cambiará el estilo:
 [class.editing]="editando">

Por último también queremos perder esta clase editing al perder el foco.Realmente vamos incluso a guardar todo al perder el foco:
  <input 
    class="edit"
    [formControl]="txtInput"
    type="text"
    #inputFisico
    (blur)="terminarEdicion()"
    >
NOTA:puedo cambiar la rigurosidad del Store con runtimeChecks:{
strictActionImmutability = false } para poder mutar el store,claro que no es lo ideal

			VIDEO 47 TOGGLE ACTION COMPLETAR O DESMARCAR UN TODO

Fijate que Fernando no creó FormControl porqué si.Recuerda que un formControl tiene la propiedad valueChanges que es un Observable.

Pero en el subscribe vamos a disparar la accion toggleTodo asi que la creo:
  export const toggleTodo = createAction(
    '[TODO] Toggle todo',
    props<{ id: number }>());

En cuanto al reducer parece que la mejor opción sería:
 on(toggleTodo,(state,{id}) => state.map(todo => {
    if(todo.id === id){
      return {
        ...todo,
        completado: !todo.completado
      }
    }
    return todo;
  })),

En cuanto al dispatch ya todo está bien claro.Inyectar y disparar:
  constructor(private store: Store<AppState>) { }

  ngOnInit(): void {
    this.checkCompletado = new FormControl(this.todo.completado);

    this.checkCompletado.valueChanges.subscribe(valor => {
      this.store.dispatch(toggleTodo({ id: this.todo.id }));
      console.log(valor);
    });

NOTA: si por algún casual muto el state,cuando intente retroceder en las ReduxDevtools no podré hacerlo,ya que no es el mismo objeto,pues lo muté(siempre usar operador spread,etc...)

IMPORTANTE: a la hora de mandar un payload a una acción yo bien podría haber pasado el Todo en vez de el id.Sin embargo esto es menos eficiente ya que tendrá que iterar primero por las propiedades del Todo y buscar el id.Lógicamente si se lo proporciono yo la operación será más rápida.

					VIDEO 48 EDITAR UNA TAREA POR HACER

Hagamos la acción de guardar trás quitar el blur.Fernando decide mandar el id y el texto:
export const editarTodo = createAction(
  '[TODO] Editar todo',
  props<{ id: number;texto: string }>());
La lógica del reducer es igual que la anterior,mapear y buscar por el id

Además es buena idea mirar que el campo no esté vacio y que sea un texto diferente:
  terminarEdicion() {
    this.editando = false;
    if (this.txtInput.invalid) {
      return;
    }
    if (this.txtInput.value === this.todo.texto) {
      return;
    }
    this.store.dispatch(actions.editarTodo({
       id: this.todo.id,
       texto: this.txtInput.value 
      }));
  }

				VIDEO 49 BORRAR UNA TAREA DE LA LISTA

Para borrar un todo creo la acción:
export const borrarTodo = createAction(
  '[TODO] Borrar todo',
  props<{ id: number }>());

Implanto la lógica en el reducer:
 on(borrarTodo, (state, { id }) => state.filter(todo => todo.id !== id)),
Fijate que filter es perfecto para borrar pues siempre regresa un nuevo arreglo

Ya solo falta disparar la acción.Fijate no hace falta mandarle el id porque ya estoy en una instancia del todo.Es muy probable que suceda repetidamente en Angular:
  deleteTodo() {
    this.store.dispatch(actions.borrarTodo({ id: this.todo.id }));
  }
Y dado que estoy suscrito a cualquier cambio en el constructor del todo-list veré reflejado el cambio instantáneamente:
this.store.select('todo').subscribe(todos => this.todos=todos

			VIDEO 50 TOGGLEALL - MARCAR O DESMARCAR TODOS LOS TODOS

Tenemos un pequeño checkbox junto al primer input.Queremos que al pulsarlo todos los todos aparezcan como completados y si se vuelve a pulsar aparezcan como no completados. 
Bien fácil,creamos el evento onClick en ese input y con la ayuda de una propiedad en la clase disparamos una accion que cambie a true o false:

 completado: boolean = false;
  constructor(private store: Store<AppState>) { }
  toggleAll(){
    this.completado = !this.completado;
    this.store.dispatch(actions.toggleAllTodos({completado: this.completado}));
  }

export const toggleAllTodos = createAction(
  '[TODO] Toggle all todos',
  props<{ completado: boolean }>());

NOTA:desde ECMA6 recuerda que puedo devolver objetos asi: => ({})
  on(toggleAllTodos, (state,{completado}) => state.map(todo => ({ ...todo,completado } ))),
Y puedo agregar o modificar una propiedad a un objeto con el operador spread{...object,apellido} y despues juntarlo con {}.Perfecto

Asi que al editar una propiedad puedo usar esta sintaxis,la cual deja bien claro lo que hace:
  on(editarTodo, (state, { id, texto }) => state.map(todo => 
     todo.id === id ? ({ ...todo, texto }) : todo  )),

Por último fijate que esa propiedad de la clase era necesaria.

			VIDEO 51 CREANDO UN SEGUNDO REDUCER - FILTROS

Si bien podríamos manejar todo dentro del mismo reducer vamos a crear un segundo reducer para las acciones del footer.Asi veremos el filtro activo actual desde el estado y las devtools pudiendo darle seguimiento.

Realmente un filtro va a ser un string(todos,activos,completados,...).No tiene mucho más.Asi que creamos la primera acción para establecer un filtro:

/* dado que pasar de tipo string es muy genérico creamos una pequeña enum */
export type filtrosValidos = 'todos' | 'completados' | 'pendientes';

export const setFilter = createAction(
  '[Filter] Set filter',
  props<{ filter: filtrosValidos }>());

En el filter.reducer.ts fijate que TS se volvió mas estricto:
Si creo un initialState:T tengo que pasarle al createReducer<T,Action> ese mismo type.
const _filterReducer = createReducer<filtrosValidos,Action>(initialState,
  on(setFilter, (state:filtrosValidos, { filter }) => filter),
)

			VIDEO 52 COMBINAR DOS O MÁS REDUCERS EN EL APPSTATE

Aún falta combinar estos dos reducers ya que sólo puede haber un rootReducer.Realmente puedo concatenar otro reducer aqui:
 StoreModule.forRoot({todos:todoReducer}),
dejandolo de esta forma:
 StoreModule.forRoot({todos:todoReducer,filtros:filterReducer}),

Pero se recomienda combinar los reducers en otro archivo y entregarle uno solo aqui.Para ello habiamos creado ya el app.reducer.ts,para combinar los reducers:

export interface AppState {
  todos:Todo[],
  filtros: filtrosValidos <- será de este tipo un filtro,claro
}
Ahora para combinar hay que usar una función con retorno ActionReducerMap<T> siendo T mi estado general,que será Appstate:
export const rootReducer:ActionReducerMap<AppState> = {
  todos: todoReducer,
  filtros:filterReducer,
 ...
Fernando la llamó appReducers(aunque sólo es uno),es indiferente,por último está claro que hay que ir al app.module y pasarle el rootReducer como único reducer
StoreModule.forRoot(rootReducer),
Ya no será un objeto,fijate,sino una referencia a la función.

				VIDEO 53 CAMBIAR EL FILTRO

Veamos como cambiar el filtro,de momento nos valdrá con cambiarlo al string que queremos al hacer click en los butttons del footer.ya implementaremos la lógica en los todos.
NOTA:ya existe el pipe titlecase para capitalizar.NO obstante,al crear un pipe hay que importarlo en el modulo donde lo voy a usar.

Simplemente creo las propiedades necesarias:
  public filtroActual!: actions.filtrosValidos;
  public filtros: actions.filtrosValidos[] = ['todos', 'completados', 'pendientes'];
  public tareasPendientes: number = 0;

  constructor(private store: Store<AppState>) {
    this.store.subscribe(state => {
      this.filtroActual = state.filtros;
      this.tareasPendientes = state.todos.filter(todo => !todo.completado).length;
    });
  }

  cambiarFiltro(filtro: actions.filtrosValidos) {
    this.store.dispatch(actions.setFilter({ filter: filtro }));
  }

Y ya tengo todo listo para la template:
 <ul class="filters">
    <li *ngFor="let filtro of filtros" style="cursor:pointer;">
      <a
        (click)="cambiarFiltro(filtro)"
        [class.selected]="filtroActual === filtro">
          {{filtro | capitalizePipe}}</a>
    </li>
  </ul>
De nuevo puedo observar el gran acierto que es usar redux en el front.

		VIDEO 54 CONTEO DE TAREAS PENDIENTES

Simplemente creamos una propiedad de tipo number y contamos la longitud del resultado de filtar los todos por no completado:

this.store.subscribe( state => {
  this.filtroActual = state.filtro;
  this.tareasPendientes = state.todos.filter(todo => !todo.completado).lenght
});
Fijate como contamos el resultado del filter.Genial.En la template se pueden usar varias aproximaciones:
  <span class="todo-count">
    <strong>{{tareasPendientes}}</strong>
    {{tareasPendientes !== 1 ? 'tareas pendientes' : 'tarea pendiente'}}
  </span>

				VIDEO 55 APLICAR EL FILTRO VISUALMENTE

Vamos a filtrar el arreglo de todos[] en base a un Pipe.Genial.Recuerda que los pipes no mutan la data,simplemente la cambian visualmente y es justo lo que quiero.
Recuerda que un pipe va a necesitar importarlo en algun otro modulo.
El pipe es muy sencillo,pero fijate en los argumentos:

 transform(todos: Todo[], filtro: filtrosValidos): Todo[] {
    switch (filtro) {
      case 'completados':
        return todos.filter(todo => todo.completado);
      case 'pendientes':
        return todos.filter(todo => !todo.completado);
      default:
        return todos;
    }
En el *ngFor lo usaré,pero con un argumento sólo:
 <app-todo-item 
    *ngFor="let todo of todos | filtro:filtroActual"
    [todo]="todo"
    >
Investigar porqué no le tengo que pasar dos argumentos y porqué en otros casos tuve que usar pipe:'argumento'.¿Es porqué es un string?

NOTA:confirmo que el valor es inferido,es decir que un pipe que tenga transform(value:any,activo:boolean) se implementará sólo con un argumento.El value siempre es pasado y es el primero además.
* Por ejemplo,este pipe va a usarse asi {{ "string cualquiera" | mayusculas:enMayusculas }} ¿Porqué?Porque el string pasa solo.
@Pipe({
   name:'mayusculas'
})
  transform( value:string, enMayusculas:boolean = true ):string {
      return enMayusculas 
         ? value.toLocaleUpperCase()
         : value.toLocaleLowerCase()
   }

Con todo esto nuestro pipe recibiirá los todos como value en el primer arg y el filter como segundo.ESto es innegociable:
transform(todos:Todo[],filter:filtrosValidos):Todo[]{}
Un simple switch/case sobre el filter valdrá.Queda claro todo.

			VIDEO 56 BORRAR TODOS LOS TODOS COMPLETADOS

Realmente limpiar los completados es bastante sencillo.La acción no necesita argumentos:
export const cleanCompleted = createAction(
  '[TODO] Clean completed');
El reducer es un simple filter que devuelve los no completados.
  on(cleanCompleted, (state) => state.filter(todo => !todo.completado))

Y disparo la acción en el (click)="limpiarCompletados()"

  limpiarCompletados() {
    this.store.dispatch(cleanCompleted());
  }

Por último fijate que puede que necesite mirar si el filtro actual ha cambiado o que haya tareas por completadas antes de disparar la acción de cambiarfiltro o limpiar tareas completadas.

				VIDEO 57 DESPLIEGUE A GITHUB PAGES 

NOTA: git pull es la combinación de git fetch y git merge
Para desplegarlo hay que crear un repositorio remoto en GitHub.

GitHubPages permite desplegar el repo como un sitio web,pero para eso debe ser un sitio web válido.Nuestro repo no lo es.

Si voy a settings veré que puedo desplegar la master branch(lo cual no funcionará por lo anterior) o la carpeta docs de la master branch.Obviamente tengo que hacer el build y ponerlo en una carpeta docs en la raiz del repo(fijate que tiene que ser docs/index.html lo que sirva yo)

Asi que hago el build y creo una carpeta docs a la que le muevo el contenido de build/folder/*
Com ya tengo un index.html en la carpeta docs puedo ir a settings y elegir esa opción.

NOTA:en Angular igual tengo que cambiar <base href="/" /> por <base href="" />
segun se sirva la app en la raiz o en relativo.

