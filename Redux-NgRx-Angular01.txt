					REDUX Y NGRX EN ANGULAR

Playlist: https://www.youtube.com/watch?v=sgFQjRL5niY&list=PLCKuOXG0bPi3FtoplJe0JOpiV6OyK30wd&index=2
* Todo lo de la playlist está en el curso de Udemy.

						SECCION 02 

NOTA: puedo ver las versiones de typescript o rxjs de Angular con ng version

En esta sección es introductoria y con mucha teoría, no se preocupen intente hacer cada video entretenido y lo suficiente explícito para que comprendan los fundamentos de Redux antes de empezar con el código.

Aquí veremos cosas como:

1- ¿Qué es Redux?
2- ¿Para qué sirve?
3- Que son las:
    a- Acciones
    b- Reducers
    c- State
    d- Store
Al final, también les dejo un enlace con la documentación oficial de Redux por si acaso quieren saber más teoría

						VIDEO 08 QUE ES REDUX

Redux no es más que un patrón para el manejo de la información.Me permitirá acceder a información que conteste a preguntas como:
¿Cual es el estado de la aplicación?
¿Cual es el valor de determinado variable?
¿Quien cambió ese valor?
¿En que momento cambió? ...etc

NOTA: puedo implementar redux en Angular,React,Vue,VanillaJs,... es un patrón agnóstico.

IDEAS PRINCIPALES:

1- Toda la data de la aplicación se encuentra en una estructura previamente definida(initialState)
2- Toda la información se encontrará almacenada en un único lugar,el STORE.Este strore normalmente contiene el 99% de la información.
3- El store JAMÁS SE MODIFICA de forma directa.Nunca muta.
4- Las interacciones del usuario y/o código dispara acciones que describen qué sucedió.Todo esto lo puedo ver en las DevTools
5- El valor actual de la información de la aplicación se llama estado-STATE
6- Un nuevo estado es creado en base a la combinación del viejo estado y una ACCIÖN,mediante una función llamada REDUCER

NOTA:recuerda que se cambia de estado tomando una acción(la cual me guiará al reducer) y el VIEJO ESTADO.El reducer tomará esa acción y el viejo estado y produce un nuevo estado.

VENTAJAS. En una aplicación pequeña, con pocas entradas y manejo de datos, implementar el redux es mucho tiempo para algo simple y poco confuso.

Pero en una aplicación con muchos componentes, con muchos servicios y modificaciones a la información, es muy difícil saber quien modificó que... o como se debería de comportar la aplicación... la idea del patrón es que sea predecible y fácil de entender por todos los desarrolladores, que quede claro qué acción es ejecutada y en qué momento se actualiza la misma.

			VIDEO 09 CONCEPTOS ACTION-REDUCER-STATE-STORE

Estas cuatro estructuras son fundamentales para entender el patrón redux.Son las acciones,el reducer,el state y el store

Action: es la única fuente de información que se envía por interacciones de usuario o programa.Por lo general,se busca que las acciones sean lo más simples posibles
Una actión únicamente tiene dos propiedades,el type y el payload,que es opcional.
El payload es la menor cantidad posible de información necesaria para realizar dicha tarea.El type si es obligatorio

Reducer: no es más que una simple función que recibe dos argumentos y siempre retorna un nuevo estado.Recibe el oldState y las acciones.
El oldState es el estado actual de la aplicación.
La action es un plain object que indica qué hay que hacer.Recuerda que las acciones y el payload deben ser lo más simples posibles.

El state:es un objeto que representa el estado de la aplicación.Tiene ciertas reglas:
1- El state es de sólo lectura
2- Nunca se mutará el state de forma directa
3- Hay funciones prohibidas de Javascript como el push(básicamente cualquier cosa que modifique objetos ya que todos los objetos son pasados por referencia).
 
El store es un objeto con las siguientes responsabilidades:
1- Contiene el estado de la aplicación
2- Permite la lectura del mismo(via getState())
3- Permite crear un nuevo estado al utilizar dispatch(ACTION)
4- Permite notificar los cambios(via subscribe())

Estos cuatro conceptos son fundamentales.Una action es un plain object con dos proiedades,un reducer toma el oldState y una action y devuelve uno nuevo.El state es un object que representa el estado de la app y el store básicamente gestiona todo por nosotros.

NOTA:puedo consultar su web oficial aquí:
 https://es.redux.js.org/ <- redux normal
Aqui en Inglés: https://redux.js.org/ <- redux toolkit

Usar la de inglés que suele ser mejor.

			SECCION 03 IMPLEMENTAR REDUX DESDE CERO EN JS 

Aquí tocaremos temas como:

1- Crear el patrón Redux desde absoluto cero
2- Integrar TypeScript para correrlo con Node
3- Crear acciones
4- Crear reducers básicos
5- Organización del proyecto y sus ejemplos
6- Manejo del Store
7- Subscripciones de cambios en el Store.

Al final de esta sección, tienen el código fuente que pueden descargar para compararlo contra el suyo en caso de ser necesario

						VIDEO 14 REDUX BÁSICO

Antes de empezar con librerias y ngRx vamos a crear un ejemplo básico,eso si,en typescript.Para usar typescript lo mejor es usar ts-node(puedo buscar en npm por el módulo).
Me pedirá instalar(siempre en global) typescript y el compilador/ejecutor ts-node:npm i -g ts-node
npm i -g typescript
Puedo ver con npm ls -g que ya los tengo.Bien podría instalarlos a nivel de proyecto en vez de en mi Sistema Operativo pero se supone que los voy a usar a menudo.
Sin embargo podría instalarlos a nivel de proyecto si fuera necesario.
npm i ts-node -D 
npm i typescript -D <- al ser typescript debería instalarlos en modo dev!

Para ejecutarlo sin la libreria de forma global puedo usar varias aproximaciones:1- npx viene incluido con la instalación de node y permite ejecutar paquetes instalados en el proyecto local:
npx ts-node app.ts
2- crear un script referenciando la libreria
scripts: {
 "run":"./node_modules/.bin/ts-node" <- pues eso

				VIDEO 15 ACCIONES Y REDUCER NIVEL BÁSICO

Para definir una acción puedo hacerlo de varias formas,pero una muy simple y sencilla es definir una interfaz con las propiedades type y payload,éste último opcional, ya que una Action debe ser un objeto que cumple esto:

interface Action {
  type: string;
  payload?:any
}

Despues ya puedo declarar acciones que cumplan este contrato:
const incrementadorAction:Action = {
   type:'INCREMENTAR'
}
Y la función reducer es una simple función que recibe un oldState(no undefined) y una  acción(ojo,recibe una).Al ser un oldState la primera vez será el initialState.Nunca puede ser undefined el state:

function reducer(state=10,action:Action){
  switch(action.type){
  	case 'INCREMENTAR':
      return state += 1;
    default:
      return state;
  }
Lógicamente no se le pasa el state=10 sino una interface/clase.

			VIDEO 16 CREANDO MÁS ACCIONES EN NUESTRO REDUCER

Puede parecer que un reducer no es más que un gigantesco switch dentro de una función,y es cierto.Sin embargo suele separarse en pequeños reducer separando la lógica de mi aplicación.
Dado que es una función pura no puedo usar peticiones http en ese switch,por ejemplo 
Importante,el operador +number no quita los decimales ni pasa a string:
+67.77777 + 1 = 68.77777 as Number
simplemente pasa a Number

Volviendo al video,destacar que cuando una acción necesita pasar un argumento se usa el payload.Como no siempre lo hará por eso es opcional:

function reducer(state = 10, action: Action) {
  switch (action.type) {
    case 'INCREMENTAR':
      return state + 1;
    case 'DECREMENTAR':
      return state - 1;
    case 'MULTIPLICAR':
      return state * +action.payload;
    case 'DIVIDIR':
      return +(state / +action.payload).toFixed(4);
    default:
      return state;
  }

				VIDEO 17 ORGANIZANDO MEJOR EL PROYECTO

No es buena idea tener todo en un archivo como tenemos ahora mismo.Asi pues creo un folder para las interfaces.Un dato interesante,la librería de redux es muy pequeña,como de unas cien líneas.
En cuanto al archivo de las acciones irá en su folder,en este caso 'contador' y es un standar ponerle .actions.
Lo mismo para el reducer es un standar usar xxxReducer en su nombre.Irá junto a las acciones para el mismo.

					VIDEO 18 STORE

Debemos crear un store que almacene el estado actual de la aplicación tras cada cambio.Al usar clases por estar en Angular cambia un poco,ya que hay que definir una clase con un getter de acceso a su propiedad privada state:

class Store<T> {
  constructo( private reducer:Reducer<T>,private state:T){}
  getState():T{ return this.state; }
}
La interfaz para esa propiedad reducer
export interface Reducer<T>{
  (state:T,action:Action):T
  }
Ahora,para crear un estado inicialializo una instancia(confirmar que es así por ser Angular).
const store = new Store(reducer,10);
* Y para acceder al state necesitaré usar el getter ya que está encapsulado.Genial:
console.log(store.getState());

Recuerda que el store tiene dos objetivos fundamentales,albergar los cambios en el state y disparar las acciones.Sin él no podría persistir los cambios en el state.
Asi pues nos falta definir el método dispatch en la clase Store:
  /* recuerda que el dispatch es una función que recibe una action por argumento.Despues retornará un newState */
  dispatch(action: Action):void{
    this.state = this.reducer(this.state,action);
  }

Lógicamente,ya no debo disparar las acciones con el reducer,sino con este método:/* Usando el dispatch del store.BIEN.Cada cambio en el state queda persistido localmente. */
store.dispatch(incrementadorAction);
store.dispatch(incrementadorAction);
console.log(store.getState());
store.dispatch(decrementadorAction);
console.log(store.getState());
store.dispatch(multiplicarAction);
console.log(store.getState());
store.dispatch(dividirAction);
console.log(store.getState());
store.dispatch(resetAction);
console.log(store.getState());

Puedo ver que ha sido facilisimo implementar este patrón en vanilla JS/TS con una simple clase,apenas dos interfaces y una función.
Por último,es un dolor de cabeza tener que usar console.log para ver el newState.Redux ya trae funcionalidad para que yo pueda ser notificado cuando cambie el estado.Nosotros somos notificados a través de un Observable al que podemos suscribirnos.Genial.

				VIDEO 19 SUSCRIBIRME A LOS CAMBIOS DEL STATE 

Dado que vamos a usar la librería de redux no vamos a tener que definir esa clase tan compleja,podríamos definir todo para poder acceder a ese Observable,pero dado que ya lo han hecho ellos desde ya vamos a usar su librería y ver como se reduce el código:
npm i redux <- recuerda que esto es para puro Javascript,faltará el adapter

Ya me proveen ellos una función que creará esa Clase,sus métodos dispatch,getState,la propiedad encapsulada state con el estado actual,etc.. Perfecto:
import { Store,createStore } from 'redux';
cons store = createStore(contadorReducer);
store.dispatch(incrementadorAction) <- tengo acceso a todo gracias a ellos
console.log(store.getState()); <- dará 11.

* Bien,pero habiamos dicho que incluso nos dan un Observable para poder suscribirnos en cada cambio del state(Store._state).

/* 4- Pero lo más genial de todo es que ya nos dan incluso un Observable para suscribirnos.Es la propia ejecución de la función createStore la que es un Observable */

/* no recibe nada en el observer,ya lo manejan ellos.Fijate que esto es genial,pues puedo ser notificado */
store.subscribe( () =>{
  console.log('Nuevo state',store.getState());
});
Fijate que esto cambia mucho de lo que tenia pensado.Podría ejecutar cualquier lógica al cambiar determinada propiedad del newState.Seguir investigando.

Redux puede ser descrito en tres principios fundamentales:Unica fuente de la verdad,el state es de solo lectura y los cambios en él se realizan con funciones puras.

NOTA:el flujo de datos en una aplicación con redux es unidireccional y siempre sigue la misma dirección y el mismo sentido:


IMPORTANTE: El ciclo de duración de la data en cualquier aplicación Redux sigue estos 4 pasos:
1- Haces una llamada a store.dispatch(action).
  Puedes invocar store.dispatch(action) desde cualquier lugar en tu aplicación, incluyendo componentes y XHR callbacks, o incluso en intervalos programados.

2- El store en Redux invoca a la función reductora que le indicaste(dado que uśe store.dispatch y la instancia store tiene acceso al método reducer).
El store pasará dos argumentos al reductor,el oldState(o estado actual) y la action.Tenga en cuenta que un reductor es una función pura.No debe realizar ningún efecto alterno como las llamadas al API o las transiciones del router. Esto debe suceder antes de que se envíe la acción.

3- El reductor raíz puede combinar la salida de múltiples reductores en un único árbol de estado.
Como se estructure el reductor raíz queda completamente a tu discreción. Redux provee una función combineReducers() si quiero combinar reductores(no es importante pues este paso)

4-El store en Redux guarda por completo el árbol de estado devuelto por el reductor raíz.
¡Este nuevo árbol es ahora el siguiente estado de tu aplicación!
Cada listener registrado usando store.subscribe(listener) será ahora invocado; los listeners podrán invocar store.getState() para obtener el estado acutal.
Ahora, la interfaz de usuario puede actualizarse para reflejar el nuevo estado(de echo un cambio actualiza la interfaz).

En cuanto a acciones asincronas ya no puedo usar el reducer.Como primera opción se usa el middleware tunk que se pone en medio del dispatch de una accion(luego es un middleware) hace lo que tenga que hacer y devuelve a la accion lo necesario:
Sin middlewares, Redux sólo soporta flujos de datos síncronos. Es lo que obtienes por defecto con createStore().
Para usar asincronia debo mejorar createStore() con applyMiddleware().

export function fetchPosts() {
  return (dispatch, getState) => {
      ... codigo aśincrono...

NOTA: Thunk middleware no es la única manera de orquestar acciones asíncronas en Redux:
1- Puedes utilizar redux-promise o redux-promise-middleware para enviar Promesas en lugar de funciones.
2- Puedes utilizar redux-observable para enviar Observables.
3- Puedes utilizar el middleware redux-saga para construir acciones asíncronas más complejas.
4- Puedes utilizar el middleware redux-pack para enviar acciones asíncronas basadas en Promesas.

Puedo observar la gran idea que es instalar redux y usar su método createStore en vez de crear yo la clase.Pero aún falta ver como usar todo esto en una aplicación de Angular.

			SECCION 04 REDUX EN UNA APLICACION DE ANGULAR

NOTA:para usar las redux dev tools en Firefox : https://addons.mozilla.org/en-US/firefox/addon/reduxdevtools/

Primero vamos a crear una jerarquia de componentes Padre Hijo Nieto y ver como se pasan props entre ellos sin redux,para ver los problemas.Despues lo haremos con redux,para poder comparar.Perfecto.

Esta sección tiene por objeto hacer una demostración del poder real de manejo centralizado de la información de nuestra aplicación... pero quiero que ustedes mismos lo descubran por su cuenta.

Aquí crearemos una aplicación básica de Angular y tocaremos temas como:

1- Creación de una aplicación de Angular de 1 componente y 2 hijos
2- Reforzamiento de temas como EventEmitter, junto a los Inputs y Outputs de Angular
3- Implementar el patrón Redux utilizando NgRx
4- Action creator
5- DevTools
6- Centralizar la lógica en acciones y reducers
7- Disparar acciones
8- Escuchar cambios en el Store
9- Y mucho más
Esta sección nos será de mucha ayuda, ya que nos permite comprender uno de los principales beneficios de trabajar con el patrón Redux

Con todo esto creo una app de angular y le instalo bootstrap(npm i bootstrap).Al instalarlo asi hay que especificarlo en el angular.json siempre.
       "styles": [
              "src/styles.css",
              "node_modules/bootstrap/dist/css/bootstrap.min.css"
            ],
Si lo pusiera el AngularCLI me dará un error asi que no tiene pérdida.

				VIDEO 25 CREACIÓN COMPONENTES ADICIONALES

Vamos a crear un par de contadores y recibir las props de forma normal entre ellos,con @Input y @Output:

El hijo simplemente recibe el contador y envia el valor nuevo al padre,ya que él puede multiplicar y dividir esa variable:number llamada contador:

export class HijoComponent implements OnInit {

  @Input() contador!:number;
  @Output() contadorChange = new EventEmitter<number>();

  constructor() { }

  multiplicar(){
    this.contador *= 2;
    this.contadorChange.emit(this.contador);
  }
  
  dividir(){
    this.contador /= 2;
    this.contadorChange.emit(this.contador);
  }

Su template no es nada del otro mundo:
<h3>Contador</h3>
<h4>{{ contador }}</h4>

<div class="row text-center">
  <div class="col">
    <button 
      (click)="multiplicar()"
       class="btn btn-primary">Multiplicar
    </button>
    <button
     (click)="dividir()"
     class="btn btn-info">Dividir
    </button>
  </div>
</div>

El padre puede incrementar y decrementar.Aparte renderiza al hijo:
<div class="row text-center mt-3">
  <div class="col">
    <button
      class="btn btn-primary me-2"
      (click)="incrementar()">
        Incrementar
      </button>
    <button 
      class="btn btn-info"
      (click)="decrementar()">
        Decrementar
      </button>
  </div>
</div>

<hr>

<div class="row text-center">
  <div class="col">
    <app-hijo 
    [contador]="contador"
    (contadorChange)="contador = ($event)">
    ></app-hijo>
  </div>
</div>

export class AppComponent {
  contador:number;

  constructor(){
    this.contador = 10;
  }

  incrementar(){
    this.contador++;
  }

  decrementar(){
    this.contador--;
  }
Realmente hasta ahora no hay problemas,aunque ya se puede apreciar los futuros problemas que tendría como dev siguiendo con este aprroach,y serán graves.

				VIDEO 26 INTEGRAR COMPONENTE NIETO

Hagamos lo mismo,renderizemos en el componente hijo al nieto:

En el nieto hacemos lo mismo,puedo recibir el contador,pero ¿que pasa si este componente también quiere hacer algo sobre el contador?.Por ejemplo un reset:

<button class="btn btn-danger"
  (click)="reset()">Reset
</button>

* Hay que mandarlo a todos ahora,claro
export class NietoComponent implements OnInit {
  @Input() contador!:number;
  @Output() resetContador = new EventEmitter();
  constructor() { }

  ngOnInit(): void {
  }

  reset(): void {
    this.contador = 0;
    this.resetContador.emit(this.contador);
  }

Claro que el hijo ahora ya no puede hacer esto:
  <div class="col">
    <app-nieto 
      [contador]="contador"
      (resetContador)="contador = $event">
    </app-nieto>

TEndrá que crearse una función en su clase que mande al padre y además actualize su propia variable contador(que es la misma ya que estamos por referencia cual prehistorics).

* Ya no puedo usar una simple igualación:
<app-nieto [contador]="contador" [resetContador)="contadorReset($event)">
* Y en la clase

  contadorReset(value: number){
    this.contador = value;
    this.contadorChange.emit(this.contador);
  }

Bien,realmente ya está pero puede apreciarse la ingente cantidad de directivas @Input y @Output creadas.Con el patrón redux no habrá que hacer esto,ya que toda la información se va a encontrar centralizada en un mismo lugar.
Veamos pues como hacer esto con redux

				VIDEO 27 IMPLEMENTAR NGRX EN UN PROYECTO

La web oficial para redux-angular(ngrx) es esta: https://ngrx.io/
Puedo ver un diagrama con el flujo de la información.En esta versión se añaden un par de cosas,ya que es un Selector(una suscripción) la que notifica a la vista cualquier cambio en el Store y a su vez un Service usará Effects(efectos) para comunicarse con el dispatch(es decir,para disparar alguna acción necesitará un efecto).Y de forma reversa,un dispatch también necesita un efecto para comunicarse con un servicio.Ya veremos todo esto.De momento instalamos la libreria:

npm install @ngrx/store

Ahora ya es ir creando las acciones,el reducer,el store y el provider.Empecemos por las acciones.Simplemente sigo la convención,creando un xxx.actions.ts:

En contador.actions.ts
/* con la función createAction obviamente puedo crear acciones */
import { createAction } from "@ngrx/store";

export const incrementar = createAction("[Contador] Incrementar");
export const decrementar = createAction("[Contador] Decrementar");

Ahora es turno del xxx.reducer.ts.De momento lo implementaremos con la típica función,aunque ya proveen ellos un método que crea un reducer:

import { Action } from "@ngrx/store";
import { decrementar, incrementar } from "./contador.actions";

export function contadorReducer(
  state:number=10,
  action:Action
  ){
  switch(action.type){
    case incrementar.type:
      return state+1;
    case decrementar.type:
      return state-1;
    default:
      return state;
  }
NOTA:Fijate que me proporcionan ellos la interfaz Action que tuvimos que crear.Realmente es la misma interfaz que creamos en la sección anterior.

Despues de las acciones y el reducer es tiempo del store.Hay que importar el StoreModule en el app.module.ts.De forma similar al Routes.forRoot() hay que pasarle el rootReducer.De momento es obvio cual es:

  imports: [
    BrowserModule,
    StoreModule.forRoot({ contador: contadorReducer }) <- contador es el nombre que le quiero dar yo,contadorReducer es el reducer

Esto de por si aún no me permite usar este Store(aunque si que lo he configurado).Al instalar ngrx/store se me habilita poder inyectar la clase Store.Hagamoslo en un punto alto(en el app.component.ts,más alto no hay):
constructor( private store:Store<{contador:number}>){
Recuerda que el store es un Observable asi que me suscribo.Puedo hacerlo en el constructor o en el ngOnInit:
  this.store.subscribe( state => {
      console.log(state);
    } );

Y lógicamente los métodos incrementar,decrementar,multiplicar,... tendré que definirlos en el reducer,darles un type,etc y llamarlos mediante esta inyección.Genial:
  incrementar(){
    // this.contador++;
    this.store.dispatch( incrementar() );
  }

  decrementar(){
    // this.contador--;
    this.store.dispatch(decrementar());
  }

NOTA:es un estandar que se importen las acciones asi:
import * as actions from 'actions/todo.actions.ts';
y ahora las llamo asi this.store.dispatch(actions.decrementar()).Investigar más sobre esto.Fijate que asi queda mucho más claro que he llamado a una acción y no a un método cualquiera,luego parece buena idea seguir esta convención.
NOTA: no se puede mutar el estado ya que si lo muto no puedo saber cual es el oldState,pues lo he mutado

				VIDEO 29 STORE DEV TOOLS

Puedo instalar el plugin Redux DevTools tanto en Chrome como Firefox(buscarlo simplemente).Aparte del plugin en Angular debo instalar esta libreria:

npm install @ngrx/store-devtools
Con esta libreria tengo acceso al StoreDevtoolsModule(el cual debo configurar).De nuevo lo importo en un punto alto(al parecer es siempre el app.module):

    StoreDevtoolsModule.instrument({
      maxAge: 25, // Retains last 25 states
      logOnly: environment.production, // si estoy en produccion las devtools son de solo lectura,si estoy en desarrollo puedo cambiar cosas del state
    }),
  ],
Puedo observar que hay que configurar el numero máximo de estados a los que puedo acceder para debuggear(esto es solo para debugging,lógicamente no hay un numero máximo de cambios que puedo realizar en mi app).
También hay que especificar cuando deben ser de modo lectura y cuando de lectura/escritura estas devtools
Ahora si que ya puedo ver la pestaña redux en las ChromeDevTools.fijate que puedo sacar la barra del históricon con el icono del reloj de abajo e ir a cada state con 'jump'.Con jump además me quedaré en ese state hasta que lo cambie

También tengo iconos para descargar el state a un json y para importarlo desde un file.
También puedo fijar un initialState con la opcion 'commit' que esta al lado del jump.
Y cuando crece mucho la app puedo verlo de forma gráfica con la opción de chart.
Con la opción de diff activada veo los cambios que se realizaron

		VIDEO 30 ESCUCHAR CAMBIOS DE UN ELEMENTO EN CONCRETO DEL STATE

Realmente casi nunca voy a querer suscribirme a TODOS los cambios que se produzcan en el state:
this.store.subscribe(state => ...) <- aqui me suscribo a todos,cualquier cambio lo va a disparar,fijate que lo que recojo es todo el state

Claro que yo sólo quiero saber cuando cambia el contador.Para ello la instancia que inyectamos 'store' ya viene con el método select.Este método me va a permitir seleccionar el nodo que me interesa:

this.store.select('contador').subscribe(contador =>) <- simplemente es pasar antes por el select.Fijate que ya no se me devuelve todo el state,sino que sería el state.contador que llamaré contador
Además,usar select limita la cantidad de emisiones:
   /* fijate que SÓLO UN CAMBIO EN EL CONTADOR DISPARA ESTE OBSERVABLE.Perfecto  */
    this.store.select('contador').subscribe( contador => this.contador = contador );
NOTA: seguir viendo redux toolkit

					VIDEO 31 CREATEREDUCER

Recuerda que nos habiamos saltado un paso.NgRx también proporciona una forma de crear la función pura reductora,no hace falta que lo haga yo(aunque puedo usar mi función si quiero)
Su función createReducer es más eficiente porque no trabaja en base a un switch.Trabaja en base a funciones suyas de la misma libreria ngrx con el objetivo de mejorar la velocidad de respuesta de mi app.
Además,también es más sencillo de implementar.Veamoslo en código:

/* FORMA CON NGRX Y CREATEREDUCER */
export const initialState = 10;
/* la función 'on' permite seleccionar más rápidamente la acción que en el switch  */
const _contadorReducer = createReducer(
  initialState,
  on(incrementar, state => state + 1),
  on(decrementar, state => state - 1)
  )

/* ojo que usar la forma anterior implica tener que realizar este paso,pues es el retorno de la función anterior lo que se exporta al store */
export function contadorReducer(state:number=initialState, action: Action) {
  return _contadorReducer(state, action);
}
/* esto asegura la no-mutación */
NOTA: TS se volvió mas estricto,hay que pasarle el tipo y valor por defecto al parámetro state.
En el siguiente video veré como pasar argumentos a las acciones.

					VIDEO 32 STORE EN EL COMPONENTE HIJO

Es momento de recuperar nuestro componente hijo.
NOTA:NaN*2 es NaN,cualquier operación sobre NaN será NaN.

Fijate que en cuanto llego a la clase del Hijo ya empiezo a ver los beneficios y la legibilidad en el código.NO necesitaré un eventEmitter ni recibir props:
/*   @Input() contador!:number;
  @Output() contadorChange = new EventEmitter<number>(); */ <- prehistoric code

NOTA:fijate que en Angular siempre estoy bajo Typescript.Esto va a cambiar varias cosas,por ejemplo Store<T> siempre será de un tipo concreto.Contodo esto inyecto la clase/Observable en el hijo:

constructor( 
    private store: Store<AppState>,
    ) {
  this.store.select('contador').subscribe(contador => this.contador = contador);
     }

Puedo observar lo fácil que es para un componente suscribirse a una parte del estado(o a varias).En el siguiente video si que veremos como usar payloads en ese createReducer de NgRx.

			VIDEO 33 CREANDO ACCIONES PARA MULTIPLICAR Y DIVIDIR

En cuanto quiera definir una accion que lleva un payload tengo que usar un segundo argumento en el createAction llamado props<T>.

export const multiplicar = createAction( "[Contador] Multiplicar",
  props<{ numero: number }>());
export const dividir = createAction( "[Contador] Dividir",
  props<{ numero: number }>());

En el reducer este argumento props viene como segundo argumento de la callback del metodo on(action.type,callback) del createReducer.Esto es fácil,asinto:
on(incrementar, (state) => state +1),
on(multiplicar, (state, {numero}) => state*numero <- ojo ,este argumento numero viene del props<T>, como era props<{numero:number}> pues la propiedad se llama numero.

NOTA: también puedo no desestructurar las props:
on(multiplicar, (state,props) => state*props.numero) 
Depende de lo que quiera yo como desarrollador.

Para llamar al dispatch de una acción cambia un poco debido a TS también:
this.store.dispatch( actions.multiplicar( {numero:2}) <- ahora es un objeto como argumento.Quizas pude usar props<number>??.Sea como sea son sólo un par de cambios.

			VIDEO 34 ACCION DE RESET DEL NIETO

Es un ejercicio,simplemente implementar el reset.Yo lo haré con props para reforzar.
NOTA:recuerda que he tenido que instalar dos librerias:
 "@ngrx/store": "^13.0.2",
 "@ngrx/store-devtools": "^13.0.2",  

					SECCION 05 TODOS-APP 

Vamos a crear la típica app de tareas,con un estado mucho más complejo que el contador anterior.También la desplegaremos en GitHubPages.Servirá para reforzar lo aprendido.
Tocaremos temas como:

1- Creación de componentes
2- Modelos
3- Acciones
4- Reducers
5- Estados
6- Estado inicial
7- Agregar tareas mediante acciones
8- Payload
9- Editar tareas
10- Despliegues a GitHub y GitHub Pages

Pero uno de los temas principales, es aclarar cómo romper la relación que tiene JavaScript con los objetos y que no sean procesados por referencia, si no que sean creados objetos nuevos. Y de esa manera siempre regresar nuevos estados.

				VIDEO 39 INICIO PROYECTO TODOS-APP


