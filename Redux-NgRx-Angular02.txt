				SECCION 06 APLICACION DE INGRESOS Y EGRESOS 

Vamos a hacer un panel administrativo,con login,graficas usando el store.En esta sección simplemente implementamos la template.

Esta sección como lo mencioné anteriormente se enfoca más en crear el HTML para nuestra aplicación

Los temas son:
1- Crear el proyecto de Angular
2- Manejo de la estructura de carpetas
3- Implementar las rutas y las rutas hijas
4- Diseñar las pantallas de la aplicación
5- Convertir un template a una aplicación de Angular

El objetivo primordial, es tener un cascaron que nos sirva para trabajar de una forma muy parecida a la realidad, a la cual nos enfrentaremos cuando implementemos este patrón en la empresa

					VIDEO 62 INICIO DEL PROYECTO

Fernando provee ya media aplicación.Copiar los assets y crear los componentes necesarios.Entre ellos las carpetas auth,shared,dashboar e ingreso-egreso.También copio los link:css.

				VIDEO 64 DISEÑO DE NUESTRA APLICACIÓN

Realmente Fernando proporcionó todo,simplemente es copiar el html a Angular.Fernando usó la versión 4.1.1 de bootstrap.Voy a usar la misma:
npm i bootstrap@4.1.1
Habrá que ir al angular.json como siempre.Recuerda que cuando modifico algo en el angular.json tengo que bajar el servidor y volver a compilar para que tome efecto ese cambio.

					VIDEO 65 CONFIGURANDO LAS RUTAS

Las rutas serán sencillas:
const routes: Routes  = 
[
  { path: 'login', component: LoginComponent },
  { path: 'register', component: RegisterComponent },
  { path: '', component: DashboardComponent },
  { path: '**', pathMatch: 'full', redirectTo: '' }

];

				VIDEO 66 CONFIGURAR RUTAS HIJAS

Realmente hay varias formas de hacer esto.Fijate en ésta,que aún no he visto.Me creo un file con las rutas(sin clase ni decorador ni nada):

En ese file declaro las rutas:
export const dashboardRoutes:Routes =
[
  {path: '', component: EstadisticaComponent},
  {path: 'ingreso-egreso', component: IngresoEgresoComponent},
  {path: 'detalle', component: DetalleComponent},
]
En el app.module padre simplemente uso children con este arreglo de rutas.
NOTA:recuerda que children lleva un arreglo de rutas por argumento y dashboardRoutes ya lo es:

const routes: Routes  = 
[
  { path: 'login', component: LoginComponent },
  { path: 'register', component: RegisterComponent },
  { path: 'dashboard', component: DashboardComponent,children: dashboardRoutes },

Al parecer hay varias formas,como la de usar module+routing.module.Investigar diferencias.

			VIDEO 68 REALIZANDO UN BACKUP DE NUESTRA APLICACIÓN

Hora de subirlo a GitHub y hacer una release-tag

		SECCION 07 	AUTENTICACIÓN DE NUESTRA APP - LOGIN Y REGISTRO

Vamos a gestionar la autenticación de nuestra aplicación con Firebase.
Aquí vamos a cubrir temas interesantes como:

1- Firebase
2- AngularFire2
3- AngularFireAuth
4- Backend y autorizaciones
5- Login
6- Register
7- Sweetalert
8- Logout
9- Grabar un documento en Firebase

Esta sección esta enfocada en manejar la parte de autenticación de nuestros usuarios, y asegurarnos que cada usuario tenga su espacio independiente en Firebase, sin contar que al final, seguiremos contando con el poder de la comunicación en tiempo real por Sockets de Firebase

					VIDEO 72 PANTALLA DE REGISTRO

Voy al register.component y creo otro campo.Usaremos formularios reactivos.
Enlazo el formulario,etc...
Fijate que bonito queda mostrar un bisé o alguna cosa cuando el campo cumple con lo requerido.Debo memorizar esto,pues lo usaré cual prehistoric:

Voy por cada control mostrando el icono segun validación de dicho control
      <span class="input-group-text"
          *ngIf="registerForm.get('password')!.valid">
         <i class="fa fa-check-circle"></i>
      </span>

				VIDEO 73-74 ENLAZAR FIREBASE CON ANGULAR-ANGULARFIRE

Crearemos un nuevo proyecto en Firebase.Habilito en auth la autenticación por correo y constraseña custom.Usaremos una base de datos normal(Firestore)
Le pongo de reglas allow read,write de momento,pero lo cambiaremos a if auth

NOTA:mandar un correo a Firebase diciendo que estoy aprendiendo a ver si me aumentan el límite | investigar sobre esto

Una vez creado el proyecto de Firebase hay que enlazarlo con la librería oficial de Angular para Firebase:
Repo: https://github.com/angular/angularfire

NOTA: npm también tiene la libreria
Si voy a usar el repo:
ng add @angular/fire
o bien(en realidad ng add usará el de npm,es tonteria usar ng add)
npm i @angular/fire

PASO UNO settear los environment files con la configuración de enlace
En Angular cambia un poco,ya que hay que agregar a ambos environments(a los dos) la configuración que me da Firebase para enlazar la app con el proyecto:

en ambos environment.ts =>
export const environment = {
  production: false,
  firebase: {
      apiKey: "xxxxx",
      authDomain: "ingreso-egreso-ngrxapp.firebaseapp.com",
      projectId: "ingreso-egreso-ngrxapp",
      storageBucket: "ingreso-egreso-ngrxapp.appspot.com",
      messagingSenderId: "1070037050213",
      appId: "x"
    }
};

PASO DOS en el AppModule me traigo el AngularFireModule
/* AngularFire */
import { AngularFireModule } from '@angular/fire/compat';
import { environment } from 'src/environments/environment';
Y lo importo al proyecto con la config anterior
imports: [
    AngularFireModule.initializeApp(environment.firebase)
  ],

PASO TRES Configurar Extras(Firestore,Auth,Storage,...)
import { AngularFireModule } from '@angular/fire/compat';
import { AngularFireAnalyticsModule } from '@angular/fire/compat/analytics';
import { AngularFirestoreModule } from '@angular/fire/compat/firestore';
import { environment } from '../environments/environment';

@NgModule({
  imports: [
    BrowserModule,
    AngularFireModule.initializeApp(environment.firebase),
    AngularFireAnalyticsModule,
    AngularFirestoreModule
  ],)

PASO CUATRO para usar firestore inyectar AngularFirestore:
export class AppComponent {
  constructor(firestore: AngularFirestore) {
  }
PASO CINCO ENLAZARSE A UNA COLECCION DE FIRESTORE:puedo suscribirme a los cambios en una coleccion de Firestore:

 items: Observable<any[]>;
 constructor(firestore: AngularFirestore) {
    this.items = firestore.collection('items').valueChanges();
  }

 <li class="text" *ngFor="let item of items | async">
    {{item.name}}
  </li>

PASO SEIS: para usar la AUth de Firebase hay que importar el modulo y despues inyectar el servicio:

import { AngularFireAuthModule} from '@angular/fire/auth' 
o bien => import { AngularFireAuthModule } from '@angular/fire/compat/auth';

RESUMEN:al final he tenido que usar todas las versiones con compatibilidad:
/* AngularFire */
import { AngularFireModule } from '@angular/fire/compat';
import { AngularFirestoreModule } from "@angular/fire/compat/firestore";
import { AngularFireAuthModule } from '@angular/fire/compat/auth';
import { environment } from 'src/environments/environment';

imports:[
  /* FORMA ANTERIOR */
    AngularFireModule.initializeApp(environment.firebase),
    AngularFirestoreModule,
    AngularFireAuthModule, ]

Puedo observar que despues cada servicio de Firebase tiene una clase para inyectar.Empecemos con el registro de un usuario.

				VIDEO 75 CREANDO NUESTRO PRIMER USUARIO

Creamos un servicio para registrar usuarios.Como voy a usar Firebase Auth inyecto la clase destinada para ello(con compatibilidad):

import { AngularFireAuth } from '@angular/fire/compat/auth';

Una vez importada esa clase simplemente uso su instancia singleton
  crearUsuario(nombre:string, email:string, password:string){
 return this.afAuth.createUserWithEmailAndPassword(email, password);

Lógicamente al crear usaré createUserWithEmailAndPassword,al logearme será signInWithEmailAndPassword,etc...

NOTA: en Firebase al crear un Usuario también se le autentica inmediatamente,luego se me proporcionará un token y un uid único.
Por último redirecciono al dashboard en un registro exitoso:
 this.router.navigate(['/dashboard']);

				VIDEO 76 LOGIN DE NUESTRA APLICACIÓN

Creo un nuevo método en el servicio authService:
  loginUsuario(email:string, password:string){
    return this.afAuth.signInWithEmailAndPassword(email, password);
  }
Y lo llamo en el submit.Poco más,asinto:

  loginUsuario(){
    if (this.loginForm.invalid) { return; }

    const { email, password } = this.loginForm.value;
    this.authService.loginUsuario(email, password)
      .then((cred) => {
        console.log(cred.user?.uid,'login');
        this.router.navigate(['/dashboard']);
      })
      .catch(err => console.log(err));
  }
NOTA: investigar diferencias entre iniciar una propiedad en la definición,el constructor o el ciclo de vida onInit.

					VIDEO 77 SWAL PARA LOS ERRORES

NOTA:sería buena idea cambiar el css del formulario del login y el register.En cuanto a la libreria simplemente la instalo y abro un Swal en los catch.

IMPORTANTE:puedo abrir un Swal con un loading cuando quiera,ya lo cerraré despues con Swal.close,que cierra la instancia que esté abierta.Genial

  crearUsuario(){
    if(this.registerForm.invalid){ return;

    Swal.fire({   <- LA ABRO AQUI
      title: 'Espere,por favor...',
      didOpen: () => { Swal.showLoading() } }) 

    const {nombre,email,password} = this.registerForm.value;

    this.authService.crearUsuario( nombre, email, password)
       .then(credenciales =>{
        //  console.log(credenciales.user?.uid,'registro');
      Swal.close();  - Y LA CIERRO AQUI

Perfecto.Es algo que no sabía y es muy útil saberlo.Puedo ver aqui lo que hace:
The promise originally returned by Swal.fire() will be resolved with this value. If no object is given, the promise is resolved with an empty SweetAlertResult object.
Closes the currently open SweetAlert2 popup programmatically.
Sin más Swal.close() cierra a Swal.fire()

					VIDEO 78 LOGOUT - CERRAR SESIÓN

El logout en Firebase no puede ser más sencillo.En el servicio usaré su instancia inyectado de AngularFireAuth:

  logout(){ return this.afAuth.signOut(); }

IMPORTANTE:a estas alturas fijate la buena idea que es dejar la autenticación a terceros.No sólo te deja tiempo,sino que seguro que está testeada y es muy confiable.
LLamo a ese servicio en el botón corrrespondiente y además redirecciono.Demasiado fácil para ser cierto,asinto.
IMPORTANTE: dado que this.afAuth.signOut():Promise devuelve una promesa y semánticamente hay que llamar al servicio y despues redireccionar mejor uso .then():

  logout() {
    this.authService.logout().then( () => this.router.navigate(['/login']));
  }

		VIDEO 79 OBTENER INFORMACIÓN DEL USUARIO ACTUAL DESDE FIREBASE

Queremos obtener toda la información respecto al usuario(cuando se conecta,cuando se desconecta,...)Para esto tengo el método authState:Observable<firebase.User> que es como el valueChanges de los forms,me permite suscribirme.

Devuelve un Observable con un firebase.User que es lo que es cada usuario para ellos.Asi que simplemente creo un método que inicie la suscripción:

  initAuthListener(){
    this.afAuth.authState.subscribe( 
      (fbUser) => {
      console.log(fbUser);
    });
  }

El punto donde suscribirme realmente cuanto más alto mejor,asi que lo haremos en el AppComponent:

export class AppComponent {
  constructor(private authService: AuthService) { 
    this.authService.initAuthListener();
  }

NOTA: dado que Angular crea el servicio en Singleton no creará más de una suscripción,siendo prácticamente innecesario el unsubscribe.

				VIDEO 80 GUARD - PROTECCIÓN DE RUTAS

Vamos a proteger el dashboard con un guard.Es muy sencillo,en la declaración de la ruta llamo al arreglo de guards con canActivate,canLoad,etc.Se llamarán justo como los métodos que implemente:

  { path: 'dashboard', 
    component: DashboardComponent,
    children: dashboardRoutes,
    canActivate: [AuthGuard]
   },
Dado que implementé el canActivate debo llamar al canActivate en el arreglo de rutas.
Lamentablemente Firebase no proporciona una propiedad isLogged,pero perfectamente podemos usar la propiedad con la que me puedo suscribir a los cambios y preguntar si el firebase.User es null,que a grosso modo es decir si estoy logeado o no:

 isAuth(){
    return this.afAuth.authState.pipe(
      map(fbUser => fbUser != null)
    );
  }
Fijate como mapeo un <User,boolean>,devolviendo justo lo que necesita el Guard(y como no se usa !== sino comparación simple.Mucho nivel hay por aqui.
IMPORTANTE: fijate que el Guard ya lanza él la suscripción.Genial.Desde luego Angular es super robusto,fiable,es Dios -_-.

  canActivate(): Observable<boolean> | boolean {
    return this.authService.isAuth();
  }
Ya se suscribe él y dispara el método en el acceso a la ruta.Increíble,que perfección,que satisfacción,que prehistoric son los demás,...

Y ya que estamos si el usuario no está autenticado le sacamos al login en vez de dejarle en esa pantalla en blanco:
  
canActivate(): Observable<boolean> | boolean {
    return this.authService.isAuth().pipe(
      tap( auth => { < auth es un firebase.User,si es null para el login
        if (!auth) { this.router.navigate(['/login']); }
      }));
  }

		VIDEO 81 CREAR DOCUMENTO EN  FIREBASE POR CADA USUARIO 

Vamos a crear un documento por cada usuario con su uid como identificador(dado que es único).Empezamos creando un modelo para un Usuario,usaremos la forma corta:

export class Usuario {
  constructor(
    public uid: string,
    public nombre: string,
    public email: string,
  ){} 

Recuerda que cada feature que use de Firebase tengo que inyectarla.Si bien he intectado AngularFireAuth ahora voy a usar Firestore luego tengo que inyectar su clase para acceder a la base de datos:

  constructor( 
      public afAuth: AngularFireAuth,
      private firestore:AngularFirestore,

El punto para crear el usuario lógicamente es en el registro,luego en el servicio que crea un usuario en Firebase,al ser una promesa,lo siguiente que hago es guardar el usuario:

  crearUsuario(nombre:string, email:string, password:string){
    return this.afAuth.createUserWithEmailAndPassword(email, password)
    .then( fbUser => {
      const { uid, email} = fbUser.user!;
      const newUser = new Usuario(uid, nombre,email!);
      return this.firestore.collection('usuarios').doc(`${uid}`).set({...newUser})
    });
El nombre lo sacamos del campo,el uid y email del firebase.User.Puedo ver como usar su autenticación es realmente sencillo.

			SECCION 08 IMPLEMENTANDO REDUX EN LA AUTENTICACIÓN

Esta sección tiene por objetivo enseñar y repasar cosas como:
1- Implementar patrón Redux y NgRx
2- Crearemos nuestro primer reducer y acciones para controlar el estado de la interfaz de usuario
3- ActionReducerMap
4- Dispatch de acciones de UI
5- Acciones del Auth
6- Reducer del Auth

Implementaremos las devtools y ya comenzaremos a trabajar con el patrón REDUX

					VIDEO 87 UIREDUCER-UISTATE

Como siempre instalo los dos módulos para Angular:
npm i @ngrx/store @ngrx/store-devtools --legacy-peer-deps

Configuro el app.module:
StoreModule.forRoot(rootReducer),
StoreDevtoolsModule.instrument({ maxAge: 25, logOnly: environment.production, }), 
Configuro el app.rootReducer que Fernando llama app.reducer:
import { ActionReducerMap } from '@ngrx/store';
import * as UI from './ngrx/ui.reducer';

export interface AppState {
   ui: UI.InitialState; 
}

export const rootReducer: ActionReducerMap<AppState> = {
   ui: UI.uiReducer,
}

Y creo alguna acción y el reducer para este pedazo del store.Fácil.Ya debería poder ver esta propiedad ui del store en las DevTools.

			VIDEO 89 DISPARAR ACCIONES ISLOADING -ISNOTLOADING

VAmos a empezar por el login.Me traigo el store y me suscribo al ui:
   
 private store: Store<AppState>) { 
    this.store.select('ui').subscribe(ui => {
      this.isLoading = ui.isLoading; }); }

Sin embargo,dejarlo asi presenta el problema que cada vez que entre al login me va a crear una suscripción nueva.Para evitar esto tengo que crearme una propiedad de tipo Suscription,almacenar la suscripción y cancelarla en el ciclo OnDestroy.

  uiSubscription!: Subscription;

 this.uiSubscription = this.store.select('ui').subscribe(ui => {
      console.log('suscripcion creada')
      this.isLoading = ui.isLoading;
    });

  ngOnDestroy(): void {
    this.uiSubscription.unsubscribe();
  }
Hago lo mismo para el registro.

					VIDEO 90 UTILIZANDO EL STORE -IS LOADING

Podemos hacer algo menos intrusivo que ese pedazo de modal.Por ejemplo cambiar el texto del botón y mostrar un pequeño spinner.
Esto es terriblemente sencillo ahora,ya que tengo la propiedad de clase boleana para usarla:

    <div class="form-group">
           <button
                *ngIf="!isLoading"
                type="submit"
                [disabled]="!loginForm.valid"
                class="btn btn-primary submit-btn btn-block">
                Login
              </button>
              <button
                *ngIf="isLoading"
                type="button"
                [disabled]="true"
                class="btn btn-primary submit-btn btn-block">
                <i class="fa fa-spin fa-sync"></i>
                Espere...
              </button>
            </div>

Puedo ver que queda más discreto.Fijate que siempre estará desactivado y que ya no es necesario que sea de tipo submit.

			VIDEO 91 AUTH.ACTIONS AUTH.REDUCER	Y NUEVO AUTHSTATE

Vamos a crear otro partialStore,lo llamaremos auth.Habrá que crear sus archivos de acciones y reducer asi como retocar el rootReducer.

En cuanto a acciones vamos a usar de momento dos,una para establecer un usuario y otra para quitarlo:

export const setUser = createAction('[Auth] setUser',
props<{user: Usuario}>());
export const unsetUser = createAction('[Auth] unsetUser');

Creo la lógica para el reducer:

const _authReducer = createReducer(initialState,
    on(setUser, (state,{user}) => ({ ...state, user: {...user} })),
    on(unsetUser, (state) => ({ ...state, user: null })),

);
Fijate que romper toda referencia puede parecer paranoico pero sin duda será efectivo.
Falta combinar los reducers,y anterior a esto crear su tipo,pues la función es ActionReducerMap<T>:
export interface AppState {
   ui: UI.InitialState; 
   auth: Auth.authInitialState;
}

export const rootReducer: ActionReducerMap<AppState> = {
   ui: UI.uiReducer,
   auth: Auth.authReducer
}

Ahora falta ver donde llamamos al setUser y al unSetUser y para ello podemos usar los Observables que me deja usar Firebase.

Primero recuerda que FirebaseAuth me deja suscribirme a los cambios en su módulo Auth,esto es fundamental entenderlo:
return this.afAuth.authState.subscribe({ <- afAuth me deja suscribirme
  next: (fbUser) => { 
    if(fbUser){
      this.firestore.collection('usuarios').doc(`${fbUser.uid}`).valueChanges()
        .subscribe( (firestoreUser) => {
          console.log(firestoreUser);

Despues de igual forma me puedo suscribir a los cambios en un documento(fijate que todo esto es muy potente).

 initAuthListener(){
    this.afAuth.authState.subscribe( (fbUser) =>{
        if(fbUser){

          this.userSubscription = this.firestore.collection('usuarios').doc(`${fbUser.uid}`).valueChanges()
            .subscribe( (firestoreUser:any) => {
            
            const { nombre, email, uid } = firestoreUser;
            const user = new Usuario(uid, nombre, email);
            this.store.dispatch(auth.setUser({user}));

          });
        } else {
          this.userSubscription.unsubscribe();
          this.store.dispatch(auth.unsetUser());
        }
      }
    );
  }

Al final quedó asi, y tuvimos que cancelar la suscripcíon ya que Firestore trabaja con sockets y hay que ser muy precisos.
No es buena práctica tener una colección por cada usuario, mejor tener una colección llamada usuarios y los usuarios estén como documentos.Fijate que esto lo hace Fernando y ya se veía que era un pequeño error.
Es un buen momento para hacer un bakcup y una release ya que está implementada la autenticación al 100%.
					
					SECCION 09 MODULO DE INGRESOS Y EGRESOS

Aquí tendremos por objetivo construir todo lo que viene después de una autenticación válida, cosas como:

1- Crear modelo de Ingresos y Egresos
2- Pantallas de captura de datos
3- Servicio de Ingreso Egreso
4- Loadings
5- Acciones y Reducer de Ingresos y Egresos
6- Leer de Firebase
7- Grabar a Firebase
8- Gráficas dinámicas
9- Y otras cosas

Primero será crear un Modelo para un IngresoEgreso:

export class IngresoEgreso {
  
  constructor(
    public description: string,
    public monto: number,
    public tipo: string,
    public uid?: string,
    public fecha?: Date
  ) {}
  
}

		VIDEO 98 PANTALLA PARA CAPTURAR INGRESOS Y EGRESOS

Esta sección es el corazón de nuestra aplicación, es con lo que nuestro usuario va a trabajar.
NOTA:siempre que se te olvide si es [formGroup] o [formGroupName] recuerda que es igual que el tipo.ylos formularios son de tipo formGroup
Dicho esto el formulario no tiene nada simplemente lo enlazo,eso sí,fijate como vamos a hacer toggle sobre un botón ingreso/egreso:
   <button (click)="tipo='egreso'"
               *ngIf="tipo === 'ingreso'"
               type="button"
               class="btn btn-primary btn-block">
               Ingreso
              </button>
              <button (click)="tipo='ingreso'"
              *ngIf="tipo === 'egreso'"
               type="button"
               class="btn btn-warning btn-block">
               Egreso
            </button> 

				VIDEO 99 SERVICIO PARA INGRESOS Y EGRESOS

Realmente no tiene mucha ciencia,salvo elegir la estructura correcta a guardar.De momento seguiré la de Fernando.

  crearIngresoEgreso(ingresoEgreso: IngresoEgreso) {
    this.firestore.doc(`${this._user!.uid}/ingresos-egresos`)
      .collection('items')
      .add({ ...ingresoEgreso })
      .then((ref) => {console.log('exito',ref)})
      .catch((error) => {console.log('error',error)});
  }

Ya lógicamente sólo falta disparar este servicio.Importante,fijate como crear un modelo ha sido fundamental:

  submitForm() {
    if (this.ingresoForm.invalid) { return; }

    const { descripcion,monto } = this.ingresoForm.value;
    const ingresoEgreso = new IngresoEgreso(descripcion, monto, this.tipo);

    this.ingresoEgresoService.crearIngresoEgreso(ingresoEgreso);
  }

Fijate que al final voy a cambiar esa promesa que resolvía en el servicio con return para resolverla más tarde:
  this.xxxx.add().then().catch() la resuelve alli

Siempre es mejor usar return en los servicios y tratar en su llamada los errores.En cuanto haga el return Promise ya tengo que usar .then en la llamada a ese método(es decir un método que  retorne una Promise debe ser llamado con .then,pero si retorna una Promise.then ya el método resuelve todo.

   this.ingresoEgresoService.crearIngresoEgreso(ingresoEgreso)
      .then(() => {
        Swal.fire('Registro Creado', descripcion, 'success');
        this.ingresoForm.reset();
      })
      .catch(err => {
        Swal.fire('Error', err.message, 'error');
      });

NOTA:para el error can't resolve all parameters:
"emitDecoratorMetadata": true En el tsconfig.json

				VIDEO 100 OPTIMIZACIONES DE LOADING

Es una tarea,simplemente implementar el spinner en base al isLoading de nuestro store.Fijate que es buena idea ese store sólo para ese boleano,que tal vez podría llevar alguna propiedad más.

			VIDEO 101 ACCIONES Y REDUCER PARA INGRESOS Y EGRESOS

De momento empezamos creando estas dos acciones:
import { createAction, props } from '@ngrx/store';
import { IngresoEgreso } from '../models/ingreso-egreso.model';

export const setItems = createAction('[IngresoEgreso] setItems',props<{items:IngresoEgreso[]}>());

export const unSetItems = createAction('[IngresoEgreso] unsetItems');

En cuanto al reducer también será algo sencillo de momento:

const _ingresoEgresoReducer = createReducer(initialState,
    on(setItems, (state, { items } ) => ({ ...state, items: [...items] })),
    on(unSetItems, state => ({ ...state, items: [] })),
);

Combino los reducers y listo. 

				VIDEO 102 CARGAR ITEMS DESDE FIREBASE

Empecemos al menos por imprimir la información por consola.
IMPORTANTE: fijate que hay un punto en que aún se está pidiendo la información a Firebase al suscribirme a auth y el user aún es null:

authInitialState :null
authInitialState {user: {…}}

  this.authSubscription = this.store.select('auth')
      .subscribe(authInitialState => {
        console.log('authInitialState', authInitialState);
        this._user = authInitialState.user;
      });

Esto es fácil de resolver,puedo usar el operador filter,el cual sólo va a dejar pasar cuando su Predicate sea true:

  this.authSubscription = this.store.select('auth')
   .pipe(filter(authInitialState => authInitialState.user != null)
      .subscribe(authInitialState => {
        console.log('authInitialState', authInitialState);
        this._user = authInitialState.user;
      });

authInitialState {user: {…}}
Aqui se nota la proacidad de Fernando -_-

Con todo esto llamo a este servicio para ver los cambios:
  
formaFernando(){
   this.firestore
     .doc(`${this._user?.uid}/ingresos-egresos`)
      .collection('items')
     .valueChanges().subscribe(console.log);
  }
Aún falta poder usar el uid de ese item.

				VIDEO 103 OBTENER EL UID DE UN ITEM

Realmente al suscribirnos al valueChanges no conseguimos ver el uid,ya que entramos hasta el documento.Para poder ver más información sobre un item de una coleccíon(en vez de sólo su contenido) hay que consultar la snapshot creada suscribiendome al snapshotChanges().Realmente Firebase es muy buen servicio.

  formaFernando(){
   this.firestore
     .doc(`${this._user?.uid}/ingresos-egresos`)
      .collection('items')
      //  .valueChanges()
      .snapshotChanges()
      .subscribe(console.log);
  }
  
Veré que en cada snapshot tengo la propiedad payload y dentro de cada payload tengo la propiedad doc(que es el documento).Dentro de ese doc ya puedo ver el id,luego tengo que entrar a payload.doc.id.
También veré a través del prototype que hay una función llamada data.
Si hago referencia a esta función veré toda la data que veia antes a través del valueChanges,es decir el contenido.Con todo esto,necesitamos el id y la data:

NOTA: Actualmente el valueChanges() puede recibir un parámetro, que devuelve el id del documento que se consulta, sería tipo:

.valueChanges({ idField: 'uid' })
Sin necesidad de usar el snapshotChanges()

			VIDEO 104 DISPATCH DE LA ACCION PARA CARGAR ITEMS

Fijate que no fue buena idea usar suscripciones en el servicio ya que vive en toda la app.Asi que he hecho lo que hizo Fernando y  es usar un componente con router-outlet que abastecerá a todos esos hijos y deja de existir al mostrar otra pagina como el login.
Lógicamente sólo hay un componente así y es el dashboard:
 userSubs!: Subscription;
  ingresoSubs!: Subscription;

  constructor(
    private store: Store<AppState>,
    private ingresoEgreso:IngresoEgresoService
    ) { }

  ngOnDestroy(): void {
    this.userSubs.unsubscribe();
    this.ingresoSubs.unsubscribe();
  }

  ngOnInit(): void {
    this.userSubs = this.store.select('auth').pipe(
       filter(auth => auth.user != null))
      .subscribe( authInitialState => {
        console.log('authInitialState', authInitialState);
        
        this.ingresoSubs = this.ingresoEgreso.initIngresoEgresoListener(authInitialState.user?.uid!)
          .subscribe( (ingresosEgresos:any[]) => {
          this.store.dispatch(setItems({ items: ingresosEgresos }));
        });

      });
  }

			VIDEO 105 MOSTRAR TODOS LOS ELEMENTOS DE INGRESO Y EGRESO

Queremos llenar la página de detalles,que es una <table> con los ingresos del usuario.Sencillo,creo la suscripción a los items del ingresoEgreso en el componente y almaceno ese arreglo en una propiedad por conveniencia y legibilidad:

   <tr *ngFor="let item of ingresosEgresos">
       <td>{{item.description}}</td>
       <td>{{item.monto | currency}}</td>
       <td>{{item.tipo}}</td>
IMPORTANTE: fijate como debo usar el pipe currency para que me saque el simbolo de $ y las comas a un numero(es decir que currency recibe un numero y lo formatea,pues yo tengo guardado un number,no un string)
Con este pipe puedo simplemente usar <input type number> y luego le paso el pipe (en React tendré que crear una función para lo mismo)

Por último fijate que nos habiamos dejado llamar al unsetItems y tenemos un lugar muy bueno para hacer esto,y es en la suscripcion a los cambios del authState que me da FirebaseAuth:

 initAuthListener(){
    this.afAuth.authState.subscribe( (fbUser) =>{
        if(fbUser){...} else{
     ...limpiar todo lo que quiera aqui
     this.store.dispatch(ie.unSetItems());

				VIDEO 106 ELIMINAR TAREAS DE FIREBASE

Realmente ya tenemos el uid,simplemente hay que borrar en Firebase.Fijate que la ruta es algo asi: /IjuDVSPZktWbXBOv2bVJGuU3BoJ3/ingresos-egresos/items/In1m6d92qCPioDonn3u4

Asi que necesito el uid del user y del ingreso.Fijate que delete(),add(),set() siempre me devuelven una Promesa así que la puedo devolver para llamar un Swal,por ejemplo:

borrarIngresoEgreso(uid: string) {
  return this.firestore.doc(`${this._user?.uid}/ingresos-egresos/items/${uid}`).delete();
}

Ahora inyecto el servicio y llamo a este método:
 
 borrarItem(uid: string) {
    this.ieService.borrarIngresoEgreso(uid)
    .then( () => Swal.fire('Borrado', 'Item borrado correctamente', 'success'))
    .catch(err => Swal.fire('Error', err.message, 'error'));
  }

Fijate que al trabajar con sockets no necesito nada más,nuestro Listener a los cambios en el documento se va a volver a disparar en tiempo real,redibujando la interfaz gráfica.Increible.

NOTA:fijate de nuevo que es una gran idea dejar una propiedad user refiriendose al user actual en el authService por ejemplo,y encapsulada:
  
  private _user!:Usuario;
  get user(){
    return {...this._user};
  }
Asi puedo quitar esa suscripción,que realmente fue mala idea.Perfecto.
Y en cuanto a que agregamos uid?:string al modelo,para que no me cree esa propiedad al guardar un ingresoEgreso simplemente la borro antes de guardarlo(dado que no es necesaria!):
crearIngresoEgreso(ingresoEgreso:IngresoEgreso){
 const uid =this.authService.user.uid; <- accedo al uid por el getter
 delete ingresoEgreso.uid; <- borro el uid del ingresoEgreso
 return this.firestore.doc(`${uid}/ingresos-egresos`)
      .collection('items')
      .add({ ...ingresoEgreso }) <- y retorno la Promise.Genial

					VIDEO 107 PIPE ORDENAR ITEMS

Queremos ordenar los items con un pipe.Todos los ingresos primero y despues los egresos.Realmente queda a discrección del desarrollador si meter el pipe en el modulo al que pertenecerá o dejarlo en una carpeta pipes.

NOTA: nos daba error porque no podemos operar ya con el items del store,ya que no dejan mutarlo.La mejor solución es no haberlo pasado por referencia,sino haber entregado una copia de él.O hacer la copia en el pipe:
  
transform( items: IngresoEgreso[]):IngresoEgreso[]  {
    if(items.length > 0){
      return [...items].sort( (a,b) => 
         (a.tipo < b.tipo) ? 1 : 
         (a.tipo > b.tipo) ? -1 : 0);
    }else{
      return items;
    }
  }
En el detalles.component.ts no rompimos la referencia,fijate:
  ngOnInit(): void {
    this.ingresosSubs = this.store.select('ingresosEgresos')
      .subscribe( ({ items }) => this.ingresosEgresos = items);
*Lógicamente al pasar al pipe ese this.ingresosEgresos le estoy pasando el items.Esto es un error y fijate que ya lo hemos echo más veces.
IMPORTANTE: nunca entregar la propiedad del store a la que me suscribo,sino una copia(a no ser que quiera justo eso,no romper la referencia.
      .subscribe( ({ items }) => this.ingresosEgresos = [...items]);
  }

NOTA:aparte de estas dos opciones se puede usar slice()que devuelve un nuevo arreglo:
items.slice().sort(...) <- al no recortar por nada devuelve el mismo arreglo,pero es una mutación del mismo.Interesante.

						VIDEO 108 COMPONENTE ESTADISTICA

En este componente vamos a hacer un sumatorio de los ingresos y los egresos.Aparte,también vamos a devolver cúantos hay.

  ngOnInit(): void {
    this.store.select('ingresosEgresos')
      .subscribe( ({ items }) => 
      this.generarEstadistica([...items]));

  }

  generarEstadistica(items:IngresoEgreso[]){
    for(let item of items){
      if(item.tipo === 'ingreso'){
        this.ingresos ++;
        this.totalIngresos += item.monto;
      }else{
        this.egresos ++;
        this.totalEgresos += item.monto;
      }
    }
  }
De nuevo,es mucho más sencillo de lo que parece.Puedo suscribirme al store parcial que yo quiera y con esa propiedad llamar a un método,algo que no había visto hasta ahora.

			VIDEO 110 NG2-CHARTS - LIBRERIA PARA GRÁFICAS EN ANGULAR

Para instalar esta libreria hay que instalar el core(chart.js) y el adapter para angular(ng2-charts):
npm install chart.js ng2-charts

Despues hay que importar el modulo al proyecto:
import { NgChartsModule } from 'ng2-charts';
// In your App's module:
imports: [ NgChartsModule ]

Ahora pedirá una serie de Labels,Options,DataSets,lo de siempre:

   // Doughnut
  public doughnutChartLabels: string[] = ['Ingresos', 'Egesos'];
  
  public doughnutChartData: ChartData<'doughnut'> = {
    labels: this.doughnutChartLabels,
    datasets: [ { data: [] }, ]
  };
  
  public doughnutChartType: ChartType = 'doughnut';
  public doughnutChartOptions: ChartConfiguration['options'] = {
    responsive: true,
    maintainAspectRatio: false,
  };
Fijate que sin pasarle una ChartConfiguration no se le podia cambiar la altura.

				VIDEO 111 COLOCAR EL NOMBRE DEL USUARIO ACTUAL

Queremos cambiar el nombre en el sideMenu por el del store.Fácil:
  username!: string;
  userSubs!: Subscription;

  ngOnDestroy(): void {
    this.userSubs.unsubscribe();
  }

  constructor(
    private store: Store<AppState>
  ) {
    this.userSubs = this.store.select('auth')
      .pipe(filter( ({user}) => user?.nombre != null))
      .subscribe( ({ user }) => this.username = user!.nombre);
  }
Recuerda que puedo filtrar para evitar los posibles primeros null y que hay que gestionar la cancelación a las suscripciones.

				SECCION 10 NGRX CON LAZYLOAD Y PROTECCION CON GUARDS

En esta sección vamos a modularizar la aplicación para implementar el lazyload.Crearemos varios modulos pues.
También usaremos esta misma técnica con el store,cargandolo perezosamente o en partes también.

Esta sección será un excelente reforzamiento al tema de los módulos de Angular y el LazyLoad de Angular, realmente de Redux, lo único que me interesa explicar el la característica forFeature del StoreModule, pero para implementarla y explicarla, necesito un ejemplo real, por lo que lo vamos a crear aquí.

Temas de la sección:

1- Módulos de Angular
2- Módulo Auth
3- Módulo Share
4- Módulo de Ingresos y Egresos
5- Dashboard Routing Module
6- Implementar LazyLoad en Angular
7- Guards
   a- Can Activate
   b-Can Load
8- Implementar el StoreModule.forFeature()

					VIDEO 116 MODULO AUTH

Empezaremos por el modulo auth:
ng g m auth/auth --flat
Fijate que esta sección recién modularizada pide el ReactiveFormsModule y el RouterModule,aparte de sus dos componentes en declarations:
@NgModule({
  declarations: [
    LoginComponent,
    RegisterComponent,
   ],
  imports: [
    CommonModule,
    ReactiveFormsModule,
    RouterModule
  ]
})
Por último,fijate que siempre debimos haber empezado a trabajar ya asi,modularizando,pero lo hicimos por motivos didácticos.
Angular sabe cuando un módulo ya esta cargado y no lo vuelve a cargar aunque este referenciado en varios lugares
Y al usar la directiva routerLink en un modulo automáticamente necesita del RouterModule ese módulo.

							VIDEO 117 MÓDULO SHARE

Fijate que todo parecia sencillo,parecia igual que el authModule,pero no.Dado que en el dashboard.html yo voy a usar <app-footer>,<app-sidebar> y el <app-navbar> tengo que exportar esos componentes.
Cuando otro modulo necesite de los componentes del modulo actual hay que exportarlos!:
@NgModule({
  declarations: [
    FooterComponent,
    NavbarComponent,
    SidebarComponent
  ],
  imports: [
    CommonModule,
    RouterModule
  ],
  exports: [
    FooterComponent,
    NavbarComponent,
    SidebarComponent
  ]
})
export class SharedModule { }

Fijate que esto me va a pasar muchisimo,es un concepto clave.Y recuerda que si Angular no encuentra una directiva necesita el módulo,por ejemplo *ngFor y *ngIf necesitarán del CommonsModule en ese módulo

					VIDEO 118 MODULO INGRESO-EGRESO

Este modulo tiene algo más de complejidad,al traer el DashboardComponent pedirá el SharedModule,aparte del pipe,formularios y las gráficas:
@NgModule({
  declarations: [
    DashboardComponent,
    IngresoEgresoComponent,
    EstadisticaComponent,
    DetalleComponent,
    OrdenarIngresosPipe,

  ],
  imports: [
    CommonModule,
    NgChartsModule,
    ReactiveFormsModule,
    SharedModule,
    RouterModule
  ],
})
export class IngresoEgresoModule { }

					VIDEO 119 DASHBOARD ROUTING MODULE

IMPORTANTE:fijate que el objetivo es que el ingresoEgresoModule cargue perezosamente,asi que hay que quitarlo de los imports en el app.module.
Lamentablemente Fernando ha mezclado muchas cosas,pero a grosso modo ha creado un app.module y un app-routing.module para las rutas:
En el modulo app.module
imports: [
    BrowserModule,
    HttpClientModule,
    AuthModule,
    AppRoutingModule, // rutas Padre <- pido al otro modulo con las rutas padre

Ese modulo de rutas padre recuerda que las configura,lo que implica importar y exportar:
const routes: Routes =
  [ { path: 'login', component: LoginComponent,  },
    { path: 'register', component: RegisterComponent,  },
    { path: 'dashboard',
      loadChildren: () => import('./ingreso-egreso/ingreso-egreso.module').then(m => m.IngesoEgresoModule)
    },
    { path: '**', pathMatch: 'full', redirectTo: 'login' }
  ];

@NgModule({
  imports: [ RouterModule.forRoot(routes) ],
  exports: [ RouterModule ]
})
export class AppRoutingModule { }

Ya estamos cargando perezosamente lo que cargue ese modulo.Recuerda que hay que apuntar al modulo entero,no al modulo o archivo de rutas:

En el padre se apunta a los modulos con todo el contenido:
    loadChildren: () => import('./ingreso-egreso/ingreso-egreso.module').then(m => m. IngresoEgresoModule)

Ese módulo IngresoEgresoModule al cargarse pedirá estos modulos,entre ellos el de sus rutas:
imports: [
    CommonModule,
    ReactiveFormsModule,
    NgChartsModule,
    SharedModule,
    DashboardRoutesModule <- al pedir a este se completa el lazyload
  ],

Su archivo de rutas luce asi:
const rutasHijas: Routes = [
  {  path: 'dashboard',
     component: DashboardComponent,
     children: dashboardRoutes,
}];

@NgModule({
  declarations: [],
  imports: [ RouterModule.forChild(rutasHijas) ],
  exports: [ RouterModule ]
})
export class DashboardRoutesModule { }
De nuevo fijate que es un archivo de configuración,luego import y export.

Incluso al levantar el ng serve ya puedo ver el lazyload en una zona llamada Lazy Chunk Files:
Lazy Chunk Files                                   | Names         |      Size
src_app_ingreso-egreso_ingreso-egreso_module_ts.js | -             | 648.65 kB

Puedo ver que los conceptos core del lazy load en Angular son:
1-eliminar el modulo de los imports del padre,ya que si no lo carga
2- usar loadChildren apuntando a ese modulo en las rutas del padre
3- el hijo cargará su propio modulo de rutas,configurado con la propiedad children(opcional).Usara RouterModule.forChild

Recalcar que nada impide al padre hacer lazyload sobre varios hijos:
const routes: Routes = [
  {
    path: 'customers',
    loadChildren: () => import('./customers/customers.module').then(m => m.CustomersModule)
  },
  {
    path: 'orders',
    loadChildren: () => import('./orders/orders.module').then(m => m.OrdersModule)
  }
];

					VIDEO 121 CANLOAD

Con los cambios que hemos hecho se nos ha quedado asi el canActivate que teniamos:
En las rutas hijas:

const rutasHijas: Routes = [
  {  path: '',
     component: DashboardComponent,
     children: dashboardRoutes,
     canActivate:[AuthGuard]  
}];
Pero esto es un error,ya que el usuario ya ha llegado hasta la ruta hija /dashboard y ha accedido a la app.
Es mejor usar canLoad y que ni siquiera pueda cargar la ruta,y en el padre.Sin embargo,debo tener en cuenta que canLoad debe activarse en cada ruta,asi que tendré que usar take(1) para que cancele la suscripción en cada cambio de ruta,volviendo a ejecutarse en el siguiente:
export class AuthGuard implements CanActivate,CanLoad {

  constructor(
    private authService: AuthService,
    private router: Router) { }
  
  canActivate(): Observable<boolean> | boolean {
    return this.authService.isAuth().pipe(
      tap( auth => {
        if (!auth) { this.router.navigate(['/login']); }
      }));
  }
  canLoad(): Observable<boolean> | boolean {
    return this.authService.isAuth().pipe(
      tap( auth => {
        if (!auth) { this.router.navigate(['/login']); }
      }),
      take(1)); <- ojo con el take(1)
  }
}
Esto es siempre asi?De todas formas es importante entender porqué se realiza cada paso.En el siguiente video vamos a ver como NO enseñar al usuario todo el árbol del store,e ir cargando o mostrandolo de igual forma que con los modulos,segun se vayan cargando los módulos.

					VIDEO 122 LAZYLOAD STORE

Para cargar de forma perezosa alguna parte del Store es casi igual que con las rutas hijas,solo que en vez de forChild(routes)se llama a forFeature(name,reducer):

DAdo que queremos cargar el ingresosEgresos.module despues también lo hacemos con su parte del store:

imports:[
 StoreModule.forFeature('ingresosEgresos', ingresoEgresoReducer),
}

Sin embargo esto también me obliga a cambiar el rootReducer y su tipado:
export interface AppState {
   ui: UI.InitialState; 
   auth: Auth.authInitialState;
   // ingresosEgresos: IE.ingresoEgresoInitialState;
}



export const rootReducer: ActionReducerMap<AppState> = {
   ui: UI.uiReducer,
   auth: Auth.authReducer,
   // ingresosEgresos: IE.ingresoEgresoReducer
}
Y al hacer esto al inyectarlo ya no podré usar esta parte que estoy cargando después,pero,obviamente,la voy a usar...:
constructor( private store: Store<AppState>,) { } <- AppState ya no tiene la propiedad ingresosEgresos.Realmente es sólo problema de la interfaz AppState.

La solución es heredar de esta interfaz en la interfaz local del ingresosEgresosReducer: 
export interface AppStateWithIngreso extends AppState {
    ingresosEgresos: ingresoEgresoInitialState; 
}
Y no inyectar el Store<AppState> sino el nuevo Store<AppStateWithIngreso>.Habré recuperado la visión sobre la propiedad ingresosEgresos.
Habrá que hacerlo en todos los archivos necesarios.

Por último puedo ver que sólo sirve para la primera vez,aunque hay formas de volver a dejar la app en ese estado inicial ocultando uno o más ramas del store,usando metaReducers:
Otra opción que puedes usar son los MetaReducers, en la documentación viene bastante información sobre ellos. Hay en especial uno que se llama clearState. En este meta reducer puedes evaluar si la acción que estás usando es un "logout", por ejemplo puedes tener un "LogoutAction". Entonces aquí puedes reconstruir tu state con lo que quieres y lo que no mantener en tu state.

			SECCION 11 DESPLEGAR APLICACIÓN EN FIREBASE HOSTING

Firebase Hosting es un servicio de hosting de contenido web con nivel de producción orientado a programadores. Con Firebase Hosting, puedes implementar apps web y contenido estático en una red de distribución de contenido global (CDN) con un solo comando, en forma rápida y sencilla.

Temas puntuales de la sección:

1- Uso del FirebaseCLI
2- FirebaseHosting
3- Despliegue a producción de nuestra aplicación
4- Pruebas de nuestra aplicación de ingreso y egreso

Es una sección pequeña pero muy valiosa

				VIDEO 128 DESPLEGAR APP EN FIREBASE HOSTING

Puedo ver la sección de Hosting al seleccionar cualquier proyecto de Firebase.
Tendré que hacer el build de la aplicación(recuerda cambiar los tamaños para el warning y el error).Muevo todo al dist.

Tendré que instalar firebase CLI en global:
npm install -g firebase-tools

* También hay más formas como con bash o mediante ejecutable.
Ya puedo acceder a firebase CLI.LO primero es identificarme con <firebase login>(me pedirá el email y la contraseña):
firebase login
Inicializo un proyecto con <firebase init>:
firebase init
Eligo sólo hosting de momento(aunque estemos usando Firestore ya)

Como opciones eligo la carpeta dist(en vez de public),eligo no sobreescribir el index.html y eligo que haga rewrite a todas las urls con index.html.Ver video de nuevo si tengo dudas

Esto creará un firebase.json y deja todo preparado para el deploy con <firebase deploy>:
firebase deploy
Esto creará una URL,y ya podré verla en la sección Hosting del proyecto.

NOTA:para que no cree siempre esa dichosa carpeta extra en dist hay que cambiar el outputPath en el angular.json:
"options": {
   "outputPath": "dist/ingreso", <- cambiar por sólo "dist"

Puedo ver más información sobre Firebase Hosting aquí:
https://firebase.google.com/docs/hosting/quickstart



