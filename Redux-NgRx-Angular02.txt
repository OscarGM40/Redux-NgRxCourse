				SECCION 06 APLICACION DE INGRESOS Y EGRESOS 

Vamos a hacer un panel administrativo,con login,graficas usando el store.En esta sección simplemente implementamos la template.

Esta sección como lo mencioné anteriormente se enfoca más en crear el HTML para nuestra aplicación

Los temas son:
1- Crear el proyecto de Angular
2- Manejo de la estructura de carpetas
3- Implementar las rutas y las rutas hijas
4- Diseñar las pantallas de la aplicación
5- Convertir un template a una aplicación de Angular

El objetivo primordial, es tener un cascaron que nos sirva para trabajar de una forma muy parecida a la realidad, a la cual nos enfrentaremos cuando implementemos este patrón en la empresa

					VIDEO 62 INICIO DEL PROYECTO

Fernando provee ya media aplicación.Copiar los assets y crear los componentes necesarios.Entre ellos las carpetas auth,shared,dashboar e ingreso-egreso.También copio los link:css.

				VIDEO 64 DISEÑO DE NUESTRA APLICACIÓN

Realmente Fernando proporcionó todo,simplemente es copiar el html a Angular.Fernando usó la versión 4.1.1 de bootstrap.Voy a usar la misma:
npm i bootstrap@4.1.1
Habrá que ir al angular.json como siempre.Recuerda que cuando modifico algo en el angular.json tengo que bajar el servidor y volver a compilar para que tome efecto ese cambio.

					VIDEO 65 CONFIGURANDO LAS RUTAS

Las rutas serán sencillas:
const routes: Routes  = 
[
  { path: 'login', component: LoginComponent },
  { path: 'register', component: RegisterComponent },
  { path: '', component: DashboardComponent },
  { path: '**', pathMatch: 'full', redirectTo: '' }

];

				VIDEO 66 CONFIGURAR RUTAS HIJAS

Realmente hay varias formas de hacer esto.Fijate en ésta,que aún no he visto.Me creo un file con las rutas(sin clase ni decorador ni nada):

En ese file declaro las rutas:
export const dashboardRoutes:Routes =
[
  {path: '', component: EstadisticaComponent},
  {path: 'ingreso-egreso', component: IngresoEgresoComponent},
  {path: 'detalle', component: DetalleComponent},
]
En el app.module padre simplemente uso children con este arreglo de rutas.
NOTA:recuerda que children lleva un arreglo de rutas por argumento y dashboardRoutes ya lo es:

const routes: Routes  = 
[
  { path: 'login', component: LoginComponent },
  { path: 'register', component: RegisterComponent },
  { path: 'dashboard', component: DashboardComponent,children: dashboardRoutes },

Al parecer hay varias formas,como la de usar module+routing.module.Investigar diferencias.

			VIDEO 68 REALIZANDO UN BACKUP DE NUESTRA APLICACIÓN

Hora de subirlo a GitHub y hacer una release-tag

		SECCION 07 	AUTENTICACIÓN DE NUESTRA APP - LOGIN Y REGISTRO

Vamos a gestionar la autenticación de nuestra aplicación con Firebase.
Aquí vamos a cubrir temas interesantes como:

1- Firebase
2- AngularFire2
3- AngularFireAuth
4- Backend y autorizaciones
5- Login
6- Register
7- Sweetalert
8- Logout
9- Grabar un documento en Firebase

Esta sección esta enfocada en manejar la parte de autenticación de nuestros usuarios, y asegurarnos que cada usuario tenga su espacio independiente en Firebase, sin contar que al final, seguiremos contando con el poder de la comunicación en tiempo real por Sockets de Firebase

					VIDEO 72 PANTALLA DE REGISTRO

Voy al register.component y creo otro campo.Usaremos formularios reactivos.
Enlazo el formulario,etc...
Fijate que bonito queda mostrar un bisé o alguna cosa cuando el campo cumple con lo requerido.Debo memorizar esto,pues lo usaré cual prehistoric:

Voy por cada control mostrando el icono segun validación de dicho control
      <span class="input-group-text"
          *ngIf="registerForm.get('password')!.valid">
         <i class="fa fa-check-circle"></i>
      </span>

				VIDEO 73-74 ENLAZAR FIREBASE CON ANGULAR-ANGULARFIRE

Crearemos un nuevo proyecto en Firebase.Habilito en auth la autenticación por correo y constraseña custom.Usaremos una base de datos normal(Firestore)
Le pongo de reglas allow read,write de momento,pero lo cambiaremos a if auth

NOTA:mandar un correo a Firebase diciendo que estoy aprendiendo a ver si me aumentan el límite | investigar sobre esto

Una vez creado el proyecto de Firebase hay que enlazarlo con la librería oficial de Angular para Firebase:
Repo: https://github.com/angular/angularfire

NOTA: npm también tiene la libreria
Si voy a usar el repo:
ng add @angular/fire
o bien(en realidad ng add usará el de npm,es tonteria usar ng add)
npm i @angular/fire

PASO UNO settear los environment files con la configuración de enlace
En Angular cambia un poco,ya que hay que agregar a ambos environments(a los dos) la configuración que me da Firebase para enlazar la app con el proyecto:

en ambos environment.ts =>
export const environment = {
  production: false,
  firebase: {
      apiKey: "xxxxx",
      authDomain: "ingreso-egreso-ngrxapp.firebaseapp.com",
      projectId: "ingreso-egreso-ngrxapp",
      storageBucket: "ingreso-egreso-ngrxapp.appspot.com",
      messagingSenderId: "1070037050213",
      appId: "x"
    }
};

PASO DOS en el AppModule me traigo el AngularFireModule
/* AngularFire */
import { AngularFireModule } from '@angular/fire/compat';
import { environment } from 'src/environments/environment';
Y lo importo al proyecto con la config anterior
imports: [
    AngularFireModule.initializeApp(environment.firebase)
  ],

PASO TRES Configurar Extras(Firestore,Auth,Storage,...)
import { AngularFireModule } from '@angular/fire/compat';
import { AngularFireAnalyticsModule } from '@angular/fire/compat/analytics';
import { AngularFirestoreModule } from '@angular/fire/compat/firestore';
import { environment } from '../environments/environment';

@NgModule({
  imports: [
    BrowserModule,
    AngularFireModule.initializeApp(environment.firebase),
    AngularFireAnalyticsModule,
    AngularFirestoreModule
  ],)

PASO CUATRO para usar firestore inyectar AngularFirestore:
export class AppComponent {
  constructor(firestore: AngularFirestore) {
  }
PASO CINCO ENLAZARSE A UNA COLECCION DE FIRESTORE:puedo suscribirme a los cambios en una coleccion de Firestore:

 items: Observable<any[]>;
 constructor(firestore: AngularFirestore) {
    this.items = firestore.collection('items').valueChanges();
  }

 <li class="text" *ngFor="let item of items | async">
    {{item.name}}
  </li>

PASO SEIS: para usar la AUth de Firebase hay que importar el modulo y despues inyectar el servicio:

import { AngularFireAuthModule} from '@angular/fire/auth' 
o bien => import { AngularFireAuthModule } from '@angular/fire/compat/auth';

RESUMEN:al final he tenido que usar todas las versiones con compatibilidad:
/* AngularFire */
import { AngularFireModule } from '@angular/fire/compat';
import { AngularFirestoreModule } from "@angular/fire/compat/firestore";
import { AngularFireAuthModule } from '@angular/fire/compat/auth';
import { environment } from 'src/environments/environment';

imports:[
  /* FORMA ANTERIOR */
    AngularFireModule.initializeApp(environment.firebase),
    AngularFirestoreModule,
    AngularFireAuthModule, ]

Puedo observar que despues cada servicio de Firebase tiene una clase para inyectar.Empecemos con el registro de un usuario.

				VIDEO 75 CREANDO NUESTRO PRIMER USUARIO

Creamos un servicio para registrar usuarios.Como voy a usar Firebase Auth inyecto la clase destinada para ello(con compatibilidad):

import { AngularFireAuth } from '@angular/fire/compat/auth';

Una vez importada esa clase simplemente uso su instancia singleton
  crearUsuario(nombre:string, email:string, password:string){
 return this.afAuth.createUserWithEmailAndPassword(email, password);

Lógicamente al crear usaré createUserWithEmailAndPassword,al logearme será signInWithEmailAndPassword,etc...

NOTA: en Firebase al crear un Usuario también se le autentica inmediatamente,luego se me proporcionará un token y un uid único.
Por último redirecciono al dashboard en un registro exitoso:
 this.router.navigate(['/dashboard']);

				VIDEO 76 LOGIN DE NUESTRA APLICACIÓN

Creo un nuevo método en el servicio authService:
  loginUsuario(email:string, password:string){
    return this.afAuth.signInWithEmailAndPassword(email, password);
  }
Y lo llamo en el submit.Poco más,asinto:

  loginUsuario(){
    if (this.loginForm.invalid) { return; }

    const { email, password } = this.loginForm.value;
    this.authService.loginUsuario(email, password)
      .then((cred) => {
        console.log(cred.user?.uid,'login');
        this.router.navigate(['/dashboard']);
      })
      .catch(err => console.log(err));
  }
NOTA: investigar diferencias entre iniciar una propiedad en la definición,el constructor o el ciclo de vida onInit.

					VIDEO 77 SWAL PARA LOS ERRORES

NOTA:sería buena idea cambiar el css del formulario del login y el register.En cuanto a la libreria simplemente la instalo y abro un Swal en los catch.

IMPORTANTE:puedo abrir un Swal con un loading cuando quiera,ya lo cerraré despues con Swal.close,que cierra la instancia que esté abierta.Genial

  crearUsuario(){
    if(this.registerForm.invalid){ return;

    Swal.fire({   <- LA ABRO AQUI
      title: 'Espere,por favor...',
      didOpen: () => { Swal.showLoading() } }) 

    const {nombre,email,password} = this.registerForm.value;

    this.authService.crearUsuario( nombre, email, password)
       .then(credenciales =>{
        //  console.log(credenciales.user?.uid,'registro');
      Swal.close();  - Y LA CIERRO AQUI

Perfecto.Es algo que no sabía y es muy útil saberlo.Puedo ver aqui lo que hace:
The promise originally returned by Swal.fire() will be resolved with this value. If no object is given, the promise is resolved with an empty SweetAlertResult object.
Closes the currently open SweetAlert2 popup programmatically.
Sin más Swal.close() cierra a Swal.fire()

					VIDEO 78 LOGOUT - CERRAR SESIÓN

El logout en Firebase no puede ser más sencillo.En el servicio usaré su instancia inyectado de AngularFireAuth:

  logout(){ return this.afAuth.signOut(); }

IMPORTANTE:a estas alturas fijate la buena idea que es dejar la autenticación a terceros.No sólo te deja tiempo,sino que seguro que está testeada y es muy confiable.
LLamo a ese servicio en el botón corrrespondiente y además redirecciono.Demasiado fácil para ser cierto,asinto.
IMPORTANTE: dado que this.afAuth.signOut():Promise devuelve una promesa y semánticamente hay que llamar al servicio y despues redireccionar mejor uso .then():

  logout() {
    this.authService.logout().then( () => this.router.navigate(['/login']));
  }

		VIDEO 79 OBTENER INFORMACIÓN DEL USUARIO ACTUAL DESDE FIREBASE

Queremos obtener toda la información respecto al usuario(cuando se conecta,cuando se desconecta,...)Para esto tengo el método authState:Observable<firebase.User> que es como el valueChanges de los forms,me permite suscribirme.

Devuelve un Observable con un firebase.User que es lo que es cada usuario para ellos.Asi que simplemente creo un método que inicie la suscripción:

  initAuthListener(){
    this.afAuth.authState.subscribe( 
      (fbUser) => {
      console.log(fbUser);
    });
  }

El punto donde suscribirme realmente cuanto más alto mejor,asi que lo haremos en el AppComponent:

export class AppComponent {
  constructor(private authService: AuthService) { 
    this.authService.initAuthListener();
  }

NOTA: dado que Angular crea el servicio en Singleton no creará más de una suscripción,siendo prácticamente innecesario el unsubscribe.

				VIDEO 80 GUARD - PROTECCIÓN DE RUTAS

Vamos a proteger el dashboard con un guard.Es muy sencillo,en la declaración de la ruta llamo al arreglo de guards con canActivate,canLoad,etc.Se llamarán justo como los métodos que implemente:

  { path: 'dashboard', 
    component: DashboardComponent,
    children: dashboardRoutes,
    canActivate: [AuthGuard]
   },
Dado que implementé el canActivate debo llamar al canActivate en el arreglo de rutas.
Lamentablemente Firebase no proporciona una propiedad isLogged,pero perfectamente podemos usar la propiedad con la que me puedo suscribir a los cambios y preguntar si el firebase.User es null,que a grosso modo es decir si estoy logeado o no:

 isAuth(){
    return this.afAuth.authState.pipe(
      map(fbUser => fbUser != null)
    );
  }
Fijate como mapeo un <User,boolean>,devolviendo justo lo que necesita el Guard(y como no se usa !== sino comparación simple.Mucho nivel hay por aqui.
IMPORTANTE: fijate que el Guard ya lanza él la suscripción.Genial.Desde luego Angular es super robusto,fiable,es Dios -_-.

  canActivate(): Observable<boolean> | boolean {
    return this.authService.isAuth();
  }
Ya se suscribe él y dispara el método en el acceso a la ruta.Increíble,que perfección,que satisfacción,que prehistoric son los demás,...

Y ya que estamos si el usuario no está autenticado le sacamos al login en vez de dejarle en esa pantalla en blanco:
  
canActivate(): Observable<boolean> | boolean {
    return this.authService.isAuth().pipe(
      tap( auth => { < auth es un firebase.User,si es null para el login
        if (!auth) { this.router.navigate(['/login']); }
      }));
  }

		VIDEO 81 CREAR DOCUMENTO EN  FIREBASE POR CADA USUARIO 

Vamos a crear un documento por cada usuario con su uid como identificador(dado que es único).Empezamos creando un modelo para un Usuario,usaremos la forma corta:

export class Usuario {
  constructor(
    public uid: string,
    public nombre: string,
    public email: string,
  ){} 

Recuerda que cada feature que use de Firebase tengo que inyectarla.Si bien he intectado AngularFireAuth ahora voy a usar Firestore luego tengo que inyectar su clase para acceder a la base de datos:

  constructor( 
      public afAuth: AngularFireAuth,
      private firestore:AngularFirestore,

El punto para crear el usuario lógicamente es en el registro,luego en el servicio que crea un usuario en Firebase,al ser una promesa,lo siguiente que hago es guardar el usuario:

  crearUsuario(nombre:string, email:string, password:string){
    return this.afAuth.createUserWithEmailAndPassword(email, password)
    .then( fbUser => {
      const { uid, email} = fbUser.user!;
      const newUser = new Usuario(uid, nombre,email!);
      return this.firestore.collection('usuarios').doc(`${uid}`).set({...newUser})
    });
El nombre lo sacamos del campo,el uid y email del firebase.User.Puedo ver como usar su autenticación es realmente sencillo.

			SECCION 08 IMPLEMENTANDO REDUX EN LA AUTENTICACIÓN

Esta sección tiene por objetivo enseñar y repasar cosas como:
1- Implementar patrón Redux y NgRx
2- Crearemos nuestro primer reducer y acciones para controlar el estado de la interfaz de usuario
3- ActionReducerMap
4- Dispatch de acciones de UI
5- Acciones del Auth
6- Reducer del Auth

Implementaremos las devtools y ya comenzaremos a trabajar con el patrón REDUX

					VIDEO 87 UIREDUCER-UISTATE

Como siempre instalo los dos módulos para Angular:
npm i @ngrx/store @ngrx/store-devtools --legacy-peer-deps

Configuro el app.module:
StoreModule.forRoot(rootReducer),
StoreDevtoolsModule.instrument({ maxAge: 25, logOnly: environment.production, }), 
Configuro el app.rootReducer que Fernando llama app.reducer:
import { ActionReducerMap } from '@ngrx/store';
import * as UI from './ngrx/ui.reducer';

export interface AppState {
   ui: UI.InitialState; 
}

export const rootReducer: ActionReducerMap<AppState> = {
   ui: UI.uiReducer,
}

Y creo alguna acción y el reducer para este pedazo del store.Fácil.Ya debería poder ver esta propiedad ui del store en las DevTools.

			VIDEO 89 DISPARAR ACCIONES ISLOADING -ISNOTLOADING




